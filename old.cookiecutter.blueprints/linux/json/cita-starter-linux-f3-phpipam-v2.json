{"status":{},"contains_secrets":false,"product_version":"3.2.2","spec":{"description":"Centos 7 Blueprint that assumes static IPv4 configuration provided by the user, ejects CDROM, runs yum update, disables SELinux and initializes data disk. Sends out an email notification on successful creation of VM.","resources":{"client_attrs":{"None":{"Profile":{"vSphere":{"Action":{},"dsl_name":"vSphere"},"AHV":{"Action":{},"dsl_name":"AHV"}},"Package":{"AHV_Package":{"Action":{},"dsl_name":"AHV_Package"},"vSphere_Package":{"Action":{},"dsl_name":"vSphere_Package"}},"Substrate":{"AHVVM":{"Action":{},"AhvVm":{"@@{vm_name}@@":{"dsl_name":"vm_name"}},"dsl_name":"AHVVM"},"vSphereVM":{"Action":{},"dsl_name":"vSphereVM"}},"Service":{"Linux":{"Action":{},"dsl_name":"Linux"}},"Deployment":{"6ca90e2b_deployment":{"Action":{},"dsl_name":"_6ca90e2b_deployment"},"04e86344_deployment":{"Action":{},"dsl_name":"_04e86344_deployment"}}}},"service_definition_list":[{"singleton":false,"action_list":[{"description":"System action for creating an application","type":"system","critical":true,"runbook":{"task_definition_list":[{"target_any_local_reference":{"kind":"app_service","name":"Linux"},"retries":"0","description":"","child_tasks_local_reference_list":[{"kind":"app_task","name":"EjectCdrom"},{"kind":"app_task","name":"UpdateRoot"},{"kind":"app_task","name":"SendMail"}],"name":"Linux___create___dag","attrs":{"edges":[{"from_task_reference":{"kind":"app_task","name":"EjectCdrom"},"edge_type":"user_defined","type":"","to_task_reference":{"kind":"app_task","name":"UpdateRoot"}},{"from_task_reference":{"kind":"app_task","name":"UpdateRoot"},"edge_type":"user_defined","type":"","to_task_reference":{"kind":"app_task","name":"SendMail"}}],"type":""},"timeout_secs":"0","type":"DAG","variable_list":[]},{"target_any_local_reference":{"kind":"app_service","name":"Linux"},"retries":"0","description":"","child_tasks_local_reference_list":[],"name":"EjectCdrom","attrs":{"exit_status":[],"script":"#!\/bin\/bash\n\n# region headers\n# * author:     stephane.bourdeaud@nutanix.com\n# * version:    v1.0\/20210504 - cita-starter version\n# task_name:    EjectCdrom\n# description:  ejects all cdrom devices (\/dev\/sr*).               \n# output vars:  none\n# dependencies: none\n# endregion\n\nfor device in \/dev\/sr*\ndo \n    sudo eject $device\n    echo \"Ejected ${device}\"\ndone","script_type":"sh","type":"","command_line_args":"","login_credential_local_reference":{"kind":"app_credential","name":"linux"}},"timeout_secs":"0","type":"EXEC","variable_list":[]},{"target_any_local_reference":{"kind":"app_service","name":"Linux"},"retries":"0","description":"","child_tasks_local_reference_list":[],"name":"UpdateRoot","attrs":{"exit_status":[],"script":"# region headers\n# * author:     stephane.bourdeaud@nutanix.com\n# * version:    v1.0\/20210504 - cita-starter version\n# task_name:    UpdateRoot\n# description:  updates root password with configured Calm credential secret.               \n# output vars:  none\n# dependencies: requires the root credential to be present in the blueprint.\n# endregion\necho 'root:@@{root.secret}@@' | sudo chpasswd","script_type":"sh","type":"","command_line_args":"","login_credential_local_reference":{"kind":"app_credential","name":"linux"}},"timeout_secs":"0","type":"EXEC","variable_list":[]},{"target_any_local_reference":{"kind":"app_service","name":"Linux"},"retries":"0","description":"","child_tasks_local_reference_list":[],"name":"SendMail","attrs":{"exit_status":[],"script":"#!\/bin\/bash\n\n# region headers\n# * author:     stephane.bourdeaud@nutanix.com\n# * version:    v1.0\/20210504 - cita-starter version\n# task_name:    SendMail\n# description:  sends an email notification to the Calm user including vm details.               \n# output vars:  none\n# dependencies: none\n# endregion\n\nsudo sed -i 's\/MaxSessions 1\/MaxSessions 10\/' \/etc\/ssh\/sshd_config\nsudo sed -i 's\/#Subsystem\/Subsystem\/' \/etc\/ssh\/sshd_config\nsudo \/bin\/systemctl restart sshd.service\nFrom=@@{email_sender}@@\nTo=@@{requester_email}@@\nSubject=\"Your VM  @@{vm_name}@@ is ready!\"\nBody=\"<html><body><p>Hello @@{vm_requester_name}@@,<\/p><p>You had requested a Linux VM, we have successfully deployed your instance and you can start using it using the following informations:\n<br>Service type: Linux instance<br>Machine ip address: @@{address}@@\n<br>Instance name: @@{vm_name}@@\n<br>Login: @@{linux.username}@@\n<br>Password: none: using your private ssh key<br>\nFor security reasons, please do not share your password or key with anyone.<br><br>Regards,<br><p>The Cloud Team<\/p><\/body><\/html>\"\necho \"\nimport email.message\nimport smtplib\nserver = smtplib.SMTP(\"\\\"@@{smtp_server}@@\\\"\", 25)\nmsg = email.message.Message()\nmsg['Subject'] = \"\\\"${Subject}\\\"\"\nmsg['From'] = \"\\\"${From}\\\"\"\nmsg['To'] = \"\\\"${To}\\\"\"\nhtml_content=\"\\\"${Body}\\\"\"\nmsg.add_header('Content-Type', 'text\/html')\nmsg.set_payload(html_content)\nserver.sendmail(msg['From'], [msg['To']], msg.as_string())\" | tee  ~\/send_notification\necho \"Sending user notification\"\npython ~\/send_notification\nrm ~\/send_notification","script_type":"sh","type":"","command_line_args":"","login_credential_local_reference":{"kind":"app_credential","name":"linux"}},"timeout_secs":"0","type":"EXEC","variable_list":[]}],"description":"","name":"Linux___create___runbook","main_task_local_reference":{"kind":"app_task","name":"Linux___create___dag"},"variable_list":[]},"name":"action_create"},{"description":"System action for starting an application","type":"system","critical":true,"runbook":{"task_definition_list":[{"target_any_local_reference":{"kind":"app_service","name":"Linux"},"retries":"0","description":"","child_tasks_local_reference_list":[],"name":"Linux___start___dag","attrs":{"edges":[],"type":""},"timeout_secs":"0","type":"DAG","variable_list":[]}],"description":"","name":"Linux___start___runbook","main_task_local_reference":{"kind":"app_task","name":"Linux___start___dag"},"variable_list":[]},"name":"action_start"},{"description":"System action for stopping an application","type":"system","critical":true,"runbook":{"task_definition_list":[{"target_any_local_reference":{"kind":"app_service","name":"Linux"},"retries":"0","description":"","child_tasks_local_reference_list":[],"name":"Linux___stop___dag","attrs":{"edges":[],"type":""},"timeout_secs":"0","type":"DAG","variable_list":[]}],"description":"","name":"Linux___stop___runbook","main_task_local_reference":{"kind":"app_task","name":"Linux___stop___dag"},"variable_list":[]},"name":"action_stop"},{"description":"System action for deleting an application. Deletes created VMs as well","type":"system","critical":true,"runbook":{"task_definition_list":[{"target_any_local_reference":{"kind":"app_service","name":"Linux"},"retries":"0","description":"","child_tasks_local_reference_list":[],"name":"Linux___delete___dag","attrs":{"edges":[],"type":""},"timeout_secs":"0","type":"DAG","variable_list":[]}],"description":"","name":"Linux___delete___runbook","main_task_local_reference":{"kind":"app_task","name":"Linux___delete___dag"},"variable_list":[]},"name":"action_delete"},{"description":"System action for restarting an application","type":"system","critical":true,"runbook":{"task_definition_list":[{"target_any_local_reference":{"kind":"app_service","name":"Linux"},"retries":"0","description":"","child_tasks_local_reference_list":[{"kind":"app_task","name":"Restart"}],"name":"Linux___restart___dag","attrs":{"edges":[],"type":""},"timeout_secs":"0","type":"DAG","variable_list":[]},{"target_any_local_reference":{"kind":"app_service","name":"Linux"},"retries":"0","description":"","child_tasks_local_reference_list":[],"name":"Restart","attrs":{"exit_status":[],"script":"# region headers\n# * author:     stephane.bourdeaud@nutanix.com\n# * version:    v1.0\/20210504 - cita-starter version\n# task_name:    Restart\n# description:  schedules a reboot 1 minute from now.               \n# output vars:  none\n# dependencies: none\n# endregion\nsudo shutdown --reboot 1","script_type":"sh","type":"","command_line_args":"","login_credential_local_reference":{"kind":"app_credential","name":"linux"}},"timeout_secs":"0","type":"EXEC","variable_list":[]}],"description":"","name":"Linux___restart___runbook","main_task_local_reference":{"kind":"app_task","name":"Linux___restart___dag"},"variable_list":[]},"name":"action_restart"},{"description":"System action for deleting an application. Does not delete created VMs","type":"system","critical":true,"runbook":{"task_definition_list":[{"target_any_local_reference":{"kind":"app_service","name":"Linux"},"retries":"0","description":"","child_tasks_local_reference_list":[],"name":"Linux___soft_delete___dag","attrs":{"edges":[],"type":""},"timeout_secs":"0","type":"DAG","variable_list":[]}],"description":"","name":"Linux___soft_delete___runbook","main_task_local_reference":{"kind":"app_task","name":"Linux___soft_delete___dag"},"variable_list":[]},"name":"action_soft_delete"}],"depends_on_list":[],"name":"Linux","port_list":[],"tier":"","variable_list":[],"description":""}],"substrate_definition_list":[{"description":"","action_list":[{"description":"","type":"fragment","critical":false,"runbook":{"task_definition_list":[{"target_any_local_reference":{"kind":"app_substrate","name":"AHVVM"},"retries":"0","description":"","child_tasks_local_reference_list":[{"kind":"app_task","name":"PhpIPAMGetSubnetId"},{"kind":"app_task","name":"PhpIPAMGetSubnet"},{"kind":"app_task","name":"PhpIPAMGetFreeIp"}],"name":"AHVVM___pre_create___dag","attrs":{"edges":[{"from_task_reference":{"kind":"app_task","name":"PhpIPAMGetSubnetId"},"edge_type":"user_defined","type":"","to_task_reference":{"kind":"app_task","name":"PhpIPAMGetSubnet"}},{"from_task_reference":{"kind":"app_task","name":"PhpIPAMGetSubnet"},"edge_type":"user_defined","type":"","to_task_reference":{"kind":"app_task","name":"PhpIPAMGetFreeIp"}}],"type":""},"timeout_secs":"0","type":"DAG","variable_list":[]},{"target_any_local_reference":{"kind":"app_substrate","name":"AHVVM"},"retries":"0","description":"","child_tasks_local_reference_list":[],"name":"PhpIPAMGetSubnetId","attrs":{"exit_status":[],"script":"# region headers\n# escript-template v20190611 \/ stephane.bourdeaud@nutanix.com\n# * author:     stephane.bourdeaud@nutanix.com\n# * version:    v2.0\/20210503 - cita-starter version\n# task_name:    PhpIPAMGetSubnetId\n# description:  Given a phpIPAM server ip\/fqdn, app id, section id,\n#               token and a vlan id, return the phpIPAM subnet object id \n#               belonging to that VLAN. Assumes only one subnet per vlan.\n# output vars:  phpipam_subnet_id\n# endregion\n\n# region capture Calm variables\n# * Capture variables here. This makes sure Calm macros are not referenced\n# * anywhere else in order to improve maintainability.\nusername = '@@{phpipam.username}@@'\nusername_secret = \"@@{phpipam.secret}@@\"\napi_server = \"@@{phpipam_ip}@@\"\nphpipam_app_id = \"@@{phpipam_app_id}@@\"\nvlan_id = \"@@{vlan_id}@@\"\nphpipam_section_id = \"@@{phpipam_section_id}@@\"\n# endregion\n\n# region prepare variables\napi_server_port = \"443\"\nsecure_calls=True\n# endregion\n\n# region API call function\nimport requests\n\ndef process_request(url, method, user, password, headers, payload=None, secure=secure_calls):\n    if payload is not None:\n        payload = json.dumps(payload)\n    \n    #configuring web request behavior\n    timeout=10\n    retries = 5\n    sleep_between_retries = 5\n    \n    while retries > 0:\n        try:\n\n            if method == 'POST':\n                    r = requests.post(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'DELETE':\n                r = requests.delete(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'GET':\n                r = requests.get(\n                    url,\n                    headers=headers,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PUT':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PATCH':\n                    r = requests.patch(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n        except requests.exceptions.HTTPError as e:\n            print (\"Http Error!\")\n            print(\"status code: {}\".format(r.status_code))\n            print(\"reason: {}\".format(r.reason))\n            print(\"text: {}\".format(r.text))\n            print(\"elapsed: {}\".format(r.elapsed))\n            print(\"headers: {}\".format(r.headers))\n            if payload is not None:\n                print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(r.content),\n                indent=4\n            ))\n            exit(r.status_code)\n        except requests.exceptions.ConnectionError as e:\n            print (\"Connection Error!\")\n            if retries == 1:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                exit(1)\n            else:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n            print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n            exit(1)\n        except requests.exceptions.Timeout as e:\n            print (\"Timeout Error!\")\n            if retries == 1:\n                raise Exception(e)\n            else:\n                print('Error! Code: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n        except requests.exceptions.RequestException as e:\n            print (\"Error!\")\n            exit(r.status_code)\n        break\n    \n    if r.ok:\n        return r\n    if r.status_code == 401:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        exit(r.status_code)\n    elif r.status_code == 500:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        exit(r.status_code)\n    else:\n        print(\"Request failed!\")\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        print(\"raise_for_status: {0}\".format(r.raise_for_status()))\n        print(\"elapsed: {0}\".format(r.elapsed))\n        print(\"headers: {0}\".format(r.headers))\n        if payload is not None:\n            print(\"payload: {0}\".format(payload))\n        print(json.dumps(\n            json.loads(r.content),\n            indent=4\n        ))\n        exit(r.status_code)\n\n# endregion\n\n\n#* get auth token\n# region get auth token\n\n# region prepare api call\n#! note that if your app security in php-ipam is set to 'none'\n#! you will have to change the port to 80 and url to http.\napi_server_endpoint = \"\/api\/{}\/user\".format(phpipam_app_id)\nurl = \"https:\/\/{}:{}{}\".format(\n    api_server,\n    api_server_port,\n    api_server_endpoint\n)\nmethod = \"POST\"\nheaders = {\n    'Content-Type': 'application\/json',\n    'Accept': 'application\/json'\n}\n# endregion\n\n# region make api call\n# make the API call and capture the results in the variable called \"resp\"\nprint(\"Making a {} API call to {}\".format(method, url))\nresp = process_request(url, method, username, username_secret, headers)\n\n# deal with the result\/response\nif resp.ok:\n    print(\"Request was successful. Status code: {}\".format(resp.status_code))\n    phpipam_token=json.loads(resp.content)['data']['token']\nelse:\n    # print the content of the response (which should have the error message)\n    print(\"Request failed!\")\n    print(\"status code: {}\".format(resp.status_code))\n    print(\"reason: {}\".format(resp.reason))\n    print(\"text: {}\".format(resp.text))\n    print(\"raise_for_status: {}\".format(resp.raise_for_status()))\n    print(\"elapsed: {}\".format(resp.elapsed))\n    print(\"headers: {}\".format(resp.headers))\n    print(\"payload: {}\".format(payload))\n    print(json.dumps(\n        json.loads(resp.content),\n        indent=4\n    ))\n    exit(1)\n# endregion\n\n# endregion\n\n#* get phpIPAM vlan object id based on vlan id number\n#region GET phpIPAM vlan object id based on vlan id number\n# region prepare api call\n#! note that if your app security in php-ipam is set to 'none'\n#! you will have to change the port to 80 and url to http.\napi_server_endpoint = \"\/api\/{}\/vlan\/\".format(phpipam_app_id)\nurl = \"https:\/\/{}:{}{}\".format(\n    api_server,\n    api_server_port,\n    api_server_endpoint\n)\nmethod = \"GET\"\nheaders = {\n    'Content-Type': 'application\/json',\n    'Accept': 'application\/json',\n    'token' : phpipam_token\n}\n# endregion\n\n# region make api call\n# make the API call and capture the results in the variable called \"resp\"\nprint(\"Making a {} API call to {}\".format(method, url))\nresp = process_request(url, method, username, username_secret, headers)\n\n# deal with the result\/response\nif resp.ok:\n    found = False\n    for vlan in json.loads(resp.text)['data']:\n        if vlan['number'] == vlan_id:\n            print(\"Found phpIPAM vlan object {} with vlan number {}\".format(vlan['vlanId'],vlan_id))\n            phpipam_vlanId = vlan['vlanId']\n            found = True\n            break\n        else:\n            continue\n    if found == False:\n        print(\"Could not find any vlan with number {}\".format(vlan_id))\n        exit(1)\nelse:\n    # print the content of the response (which should have the error message)\n    print(\"Request failed!\")\n    print(\"status code: {}\".format(resp.status_code))\n    print(\"reason: {}\".format(resp.reason))\n    print(\"text: {}\".format(resp.text))\n    print(\"raise_for_status: {}\".format(resp.raise_for_status()))\n    print(\"elapsed: {}\".format(resp.elapsed))\n    print(\"headers: {}\".format(resp.headers))\n    print(\"payload: {}\".format(payload))\n    print(json.dumps(\n        json.loads(resp.content),\n        indent=4\n    ))\n    exit(1)\n# endregion\n\n#endregion\n\n#* get subnets and match with phpIPAM vlan object id\n#region GET subnets and match with phpIPAM vlan object id\n# region prepare api call\n#! note that if your app security in php-ipam is set to 'none'\n#! you will have to change the port to 80 and url to http.\napi_server_endpoint = \"\/api\/{}\/sections\/{}\/subnets\".format(phpipam_app_id,phpipam_section_id)\nurl = \"https:\/\/{}:{}{}\".format(\n    api_server,\n    api_server_port,\n    api_server_endpoint\n)\nmethod = \"GET\"\nheaders = {\n    'Content-Type': 'application\/json',\n    'Accept': 'application\/json',\n    'token' : phpipam_token\n}\n# endregion\n\n# region make api call\n# make the API call and capture the results in the variable called \"resp\"\nprint(\"Making a {} API call to {}\".format(method, url))\nresp = process_request(url, method, username, username_secret, headers)\n\n# deal with the result\/response\nif resp.ok:\n    print(\"Request was successful. Status code: {}\".format(resp.status_code))\n    #print('Response: {}'.format(json.dumps(json.loads(resp.content), indent=4)))\n    found = False\n    for subnet in json.loads(resp.text)['data']:\n        if subnet['vlanId'] == phpipam_vlanId:\n            print(\"phpipam_subnet_id= {}\".format(subnet['id']))\n            found = True\n            break\n        else:\n            continue\n    if found == False:\n        print(\"Could not find a subnet for vlan object id {} with vlan number {}!\".format(phpipam_vlanId,vlan_id))\n        exit(1)\nelse:\n    # print the content of the response (which should have the error message)\n    print(\"Request failed!\")\n    print(\"status code: {}\".format(resp.status_code))\n    print(\"reason: {}\".format(resp.reason))\n    print(\"text: {}\".format(resp.text))\n    print(\"raise_for_status: {}\".format(resp.raise_for_status()))\n    print(\"elapsed: {}\".format(resp.elapsed))\n    print(\"headers: {}\".format(resp.headers))\n    print(\"payload: {}\".format(payload))\n    print(json.dumps(\n        json.loads(resp.content),\n        indent=4\n    ))\n    exit(1)\n# endregion\n#endregion\n\n#* revoke token\n# region revoke auth token\n\n# region prepare api call\n#! note that if your app security in php-ipam is set to 'none'\n#! you will have to change the port to 80 and url to http.\napi_server_endpoint = \"\/api\/{}\/user\".format(phpipam_app_id)\nurl = \"https:\/\/{}:{}{}\".format(\n    api_server,\n    api_server_port,\n    api_server_endpoint\n)\nmethod = \"DELETE\"\nheaders = {\n    'Content-Type': 'application\/json',\n    'Accept': 'application\/json',\n    'token' : phpipam_token\n}\n# endregion\n\n# region make api call\n# make the API call and capture the results in the variable called \"resp\"\nprint(\"Making a {} API call to {}\".format(method, url))\nresp = process_request(url, method, username, username_secret, headers)\n\n# deal with the result\/response\nif resp.ok:\n    print(\"Request was successful. Status code: {}\".format(resp.status_code))\n    print(\"Token was revoked\")\nelse:\n    # print the content of the response (which should have the error message)\n    print(\"Request failed!\")\n    print(\"status code: {}\".format(resp.status_code))\n    print(\"reason: {}\".format(resp.reason))\n    print(\"text: {}\".format(resp.text))\n    print(\"raise_for_status: {}\".format(resp.raise_for_status()))\n    print(\"elapsed: {}\".format(resp.elapsed))\n    print(\"headers: {}\".format(resp.headers))\n    print(\"payload: {}\".format(payload))\n    print(json.dumps(\n        json.loads(resp.content),\n        indent=4\n    ))\n    exit(1)\n# endregion\n\n# endregion\n","eval_variables":["phpipam_subnet_id"],"eval_scope":"local","type":"","script_type":"static"},"timeout_secs":"0","type":"SET_VARIABLE","variable_list":[]},{"target_any_local_reference":{"kind":"app_substrate","name":"AHVVM"},"retries":"0","description":"","child_tasks_local_reference_list":[],"name":"PhpIPAMGetSubnet","attrs":{"exit_status":[],"script":"# region headers\n# escript-template v20190611 \/ stephane.bourdeaud@nutanix.com\n# * author:     stephane.bourdeaud@nutanix.com\n# * version:    v2.0\/20210503 - cita-starter version\n# task_name:    PhpIPAMGetSubnet\n# description:  Given a php-ipam server ip\/fqdn, and a subnet id, return\n#               information about that subnet (mask, gateway, used IPs, \n#               total IPs, free IPs). It assumes the gateway and nameservers\n#               have been defined on the subnet.\n# output vars:  phpipam_subnet_mask, phpipam_subnet_bitmask,  \n#               phpipam_subnet_gateway, phpipam_subnet_total_ips,\n#               phpipam_subnet_nameservers\n# endregion\n\n# region capture Calm variables\n# * Capture variables here. This makes sure Calm macros are not referenced\n# * anywhere else in order to improve maintainability.\nusername = '@@{phpipam.username}@@'\nusername_secret = \"@@{phpipam.secret}@@\"\napi_server = \"@@{phpipam_ip}@@\"\nphpipam_app_id = \"@@{phpipam_app_id}@@\"\nphpipam_subnet_id = \"@@{phpipam_subnet_id}@@\"\n# endregion\n\n# region prepare variables\napi_server_port = \"443\"\nsecure_calls=True\n# endregion\n\n# region API call function\nimport requests\n\ndef process_request(url, method, user, password, headers, payload=None, secure=secure_calls):\n    if payload is not None:\n        payload = json.dumps(payload)\n    \n    #configuring web request behavior\n    timeout=10\n    retries = 5\n    sleep_between_retries = 5\n    \n    while retries > 0:\n        try:\n\n            if method == 'POST':\n                    r = requests.post(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'DELETE':\n                r = requests.delete(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'GET':\n                r = requests.get(\n                    url,\n                    headers=headers,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PUT':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PATCH':\n                    r = requests.patch(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n        except requests.exceptions.HTTPError as e:\n            print (\"Http Error!\")\n            print(\"status code: {}\".format(r.status_code))\n            print(\"reason: {}\".format(r.reason))\n            print(\"text: {}\".format(r.text))\n            print(\"elapsed: {}\".format(r.elapsed))\n            print(\"headers: {}\".format(r.headers))\n            if payload is not None:\n                print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(r.content),\n                indent=4\n            ))\n            exit(r.status_code)\n        except requests.exceptions.ConnectionError as e:\n            print (\"Connection Error!\")\n            if retries == 1:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                exit(1)\n            else:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n            print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n            exit(1)\n        except requests.exceptions.Timeout as e:\n            print (\"Timeout Error!\")\n            if retries == 1:\n                raise Exception(e)\n            else:\n                print('Error! Code: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n        except requests.exceptions.RequestException as e:\n            print (\"Error!\")\n            exit(r.status_code)\n        break\n    \n    if r.ok:\n        return r\n    if r.status_code == 401:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        exit(r.status_code)\n    elif r.status_code == 500:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        exit(r.status_code)\n    else:\n        print(\"Request failed!\")\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        print(\"raise_for_status: {0}\".format(r.raise_for_status()))\n        print(\"elapsed: {0}\".format(r.elapsed))\n        print(\"headers: {0}\".format(r.headers))\n        if payload is not None:\n            print(\"payload: {0}\".format(payload))\n        print(json.dumps(\n            json.loads(r.content),\n            indent=4\n        ))\n        exit(r.status_code)\n\n# endregion\n\n\n#* get auth token\n# region get auth token\n\n# region prepare api call\n#! note that if your app security in php-ipam is set to 'none'\n#! you will have to change the port to 80 and url to http.\napi_server_endpoint = \"\/api\/{}\/user\".format(phpipam_app_id)\nurl = \"https:\/\/{}:{}{}\".format(\n    api_server,\n    api_server_port,\n    api_server_endpoint\n)\nmethod = \"POST\"\nheaders = {\n    'Content-Type': 'application\/json',\n    'Accept': 'application\/json'\n}\n# endregion\n\n# region make api call\n# make the API call and capture the results in the variable called \"resp\"\nprint(\"Making a {} API call to {}\".format(method, url))\nresp = process_request(url, method, username, username_secret, headers)\n\n# deal with the result\/response\nif resp.ok:\n    print(\"Request was successful. Status code: {}\".format(resp.status_code))\n    phpipam_token=json.loads(resp.content)['data']['token']\nelse:\n    # print the content of the response (which should have the error message)\n    print(\"Request failed!\")\n    print(\"status code: {}\".format(resp.status_code))\n    print(\"reason: {}\".format(resp.reason))\n    print(\"text: {}\".format(resp.text))\n    print(\"raise_for_status: {}\".format(resp.raise_for_status()))\n    print(\"elapsed: {}\".format(resp.elapsed))\n    print(\"headers: {}\".format(resp.headers))\n    print(\"payload: {}\".format(payload))\n    print(json.dumps(\n        json.loads(resp.content),\n        indent=4\n    ))\n    exit(1)\n# endregion\n\n# endregion\n\n#* get subnet details\n#region get subnet details\n\n# region prepare api call\n#! note that if your app security in php-ipam is set to 'none'\n#! you will have to change the port to 80 and url to http.\napi_server_endpoint = \"\/api\/{}\/subnets\/{}\/\".format(phpipam_app_id,phpipam_subnet_id)\nurl = \"https:\/\/{}:{}{}\".format(\n    api_server,\n    api_server_port,\n    api_server_endpoint\n)\nmethod = \"GET\"\nheaders = {\n    'Content-Type': 'application\/json',\n    'Accept': 'application\/json',\n    'token' : phpipam_token\n}\n# endregion\n\n# region make api call\n# make the API call and capture the results in the variable called \"resp\"\nprint(\"Making a {} API call to {}\".format(method, url))\nresp = process_request(url, method, username, username_secret, headers)\n\n# deal with the result\/response\nif resp.ok:\n    print(\"Request was successful. Status code: {}\".format(resp.status_code))\n    #print('Response: {}'.format(json.dumps(json.loads(resp.content), indent=4)))\n    dns_servers=json.loads(resp.content)['data']['nameservers']['namesrv1']\n    dns_servers=dns_servers.split(';')\n    print(\"subnet_mask= {}\".format(json.loads(resp.content)['data']['calculation']['Subnet netmask']))\n    print(\"subnet_mask_bits= {}\".format(json.loads(resp.content)['data']['calculation']['Subnet bitmask']))\n    print(\"gateway= {}\".format(json.loads(resp.content)['data']['gateway']['ip_addr']))\n    print(\"dns1= {}\".format(dns_servers[0]))\n    print(\"dns2= {}\".format(dns_servers[1]))\nelse:\n    # print the content of the response (which should have the error message)\n    print(\"Request failed!\")\n    print(\"status code: {}\".format(resp.status_code))\n    print(\"reason: {}\".format(resp.reason))\n    print(\"text: {}\".format(resp.text))\n    print(\"raise_for_status: {}\".format(resp.raise_for_status()))\n    print(\"elapsed: {}\".format(resp.elapsed))\n    print(\"headers: {}\".format(resp.headers))\n    print(\"payload: {}\".format(payload))\n    print(json.dumps(\n        json.loads(resp.content),\n        indent=4\n    ))\n    exit(1)\n# endregion\n\n# endregion\n\n#* revoke token\n# region revoke auth token\n\n# region prepare api call\n#! note that if your app security in php-ipam is set to 'none'\n#! you will have to change the port to 80 and url to http.\napi_server_endpoint = \"\/api\/{}\/user\".format(phpipam_app_id)\nurl = \"https:\/\/{}:{}{}\".format(\n    api_server,\n    api_server_port,\n    api_server_endpoint\n)\nmethod = \"DELETE\"\nheaders = {\n    'Content-Type': 'application\/json',\n    'Accept': 'application\/json',\n    'token' : phpipam_token\n}\n# endregion\n\n# region make api call\n# make the API call and capture the results in the variable called \"resp\"\nprint(\"Making a {} API call to {}\".format(method, url))\nresp = process_request(url, method, username, username_secret, headers)\n\n# deal with the result\/response\nif resp.ok:\n    print(\"Request was successful. Status code: {}\".format(resp.status_code))\n    print(\"Token was revoked\")\nelse:\n    # print the content of the response (which should have the error message)\n    print(\"Request failed!\")\n    print(\"status code: {}\".format(resp.status_code))\n    print(\"reason: {}\".format(resp.reason))\n    print(\"text: {}\".format(resp.text))\n    print(\"raise_for_status: {}\".format(resp.raise_for_status()))\n    print(\"elapsed: {}\".format(resp.elapsed))\n    print(\"headers: {}\".format(resp.headers))\n    print(\"payload: {}\".format(payload))\n    print(json.dumps(\n        json.loads(resp.content),\n        indent=4\n    ))\n    exit(1)\n# endregion\n\n# endregion\n","eval_variables":["subnet_mask_bits","subnet_mask","gateway","dns1","dns2"],"eval_scope":"local","type":"","script_type":"static"},"timeout_secs":"0","type":"SET_VARIABLE","variable_list":[]},{"target_any_local_reference":{"kind":"app_substrate","name":"AHVVM"},"retries":"0","description":"","child_tasks_local_reference_list":[],"name":"PhpIPAMGetFreeIp","attrs":{"exit_status":[],"script":"# region headers\n# escript-template v20190611 \/ stephane.bourdeaud@nutanix.com\n# TODO Fill in this section with your information\n# * author:     stephane.bourdeaud@nutanix.com, igor.zecevic@nutanix.com\n# * version:    v2.1\/20210504 - cita-starter version\n# task_name:    PhpIPAMGetFreeIp\n# description:  Given a phpIPAM server ip\/fqdn, a phpIPAM app id, a token\n#               and a subnet id, return the first available IP address in \n#               that subnet. The current VM name and Calm user will be used\n#               for ip registration with ipam.               \n# outputvars:   phpipam_free_ip\n# endregion\n\n# region capture Calm variables\nusername = '@@{phpipam.username}@@'\nusername_secret = \"@@{phpipam.secret}@@\"\napi_server = \"@@{phpipam_ip}@@\"\nphpipam_app_id = \"@@{phpipam_app_id}@@\"\nphpipam_subnet_id = \"@@{phpipam_subnet_id}@@\"\nhostname = \"@@{vm_name}@@.@@{domain}@@\"\nowner = \"@@{calm_username}@@\" #* this is a built-in Calm macro which returns the Calm user username\n# endregion\n\n# region prepare variables\napi_server_port = \"443\"\nsecure_calls=True\n# endregion\n\n# region API call function\nimport requests\n\ndef process_request(url, method, user, password, headers, payload=None, secure=secure_calls):\n    if payload is not None:\n        payload = json.dumps(payload)\n    \n    #configuring web request behavior\n    timeout=10\n    retries = 5\n    sleep_between_retries = 5\n    \n    while retries > 0:\n        try:\n\n            if method == 'POST':\n                    r = requests.post(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'DELETE':\n                r = requests.delete(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'GET':\n                r = requests.get(\n                    url,\n                    headers=headers,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PUT':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PATCH':\n                    r = requests.patch(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n        except requests.exceptions.HTTPError as e:\n            print (\"Http Error!\")\n            print(\"status code: {}\".format(r.status_code))\n            print(\"reason: {}\".format(r.reason))\n            print(\"text: {}\".format(r.text))\n            print(\"elapsed: {}\".format(r.elapsed))\n            print(\"headers: {}\".format(r.headers))\n            if payload is not None:\n                print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(r.content),\n                indent=4\n            ))\n            exit(r.status_code)\n        except requests.exceptions.ConnectionError as e:\n            print (\"Connection Error!\")\n            if retries == 1:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                exit(1)\n            else:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n            print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n            exit(1)\n        except requests.exceptions.Timeout as e:\n            print (\"Timeout Error!\")\n            if retries == 1:\n                raise Exception(e)\n            else:\n                print('Error! Code: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n        except requests.exceptions.RequestException as e:\n            print (\"Error!\")\n            exit(r.status_code)\n        break\n    \n    if r.ok:\n        return r\n    if r.status_code == 401:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        exit(r.status_code)\n    elif r.status_code == 500:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        exit(r.status_code)\n    else:\n        print(\"Request failed!\")\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        print(\"raise_for_status: {0}\".format(r.raise_for_status()))\n        print(\"elapsed: {0}\".format(r.elapsed))\n        print(\"headers: {0}\".format(r.headers))\n        if payload is not None:\n            print(\"payload: {0}\".format(payload))\n        print(json.dumps(\n            json.loads(r.content),\n            indent=4\n        ))\n        exit(r.status_code)\n        \n# endregion\n\n\n#* get auth token\n# region get auth token\n\n# region prepare api call\n#! note that if your app security in php-ipam is set to 'none'\n#! you will have to change the port to 80 and url to http.\napi_server_endpoint = \"\/api\/{}\/user\".format(phpipam_app_id)\nurl = \"https:\/\/{}:{}{}\".format(\n    api_server,\n    api_server_port,\n    api_server_endpoint\n)\nmethod = \"POST\"\nheaders = {\n    'Content-Type': 'application\/json',\n    'Accept': 'application\/json'\n}\n# endregion\n\n# region make api call\n# make the API call and capture the results in the variable called \"resp\"\nprint(\"Making a {} API call to {}\".format(method, url))\nresp = process_request(url, method, username, username_secret, headers)\n\n# deal with the result\/response\nif resp.ok:\n    print(\"Request was successful. Status code: {}\".format(resp.status_code))\n    phpipam_token=json.loads(resp.content)['data']['token']\nelse:\n    # print the content of the response (which should have the error message)\n    print(\"Request failed!\")\n    print(\"status code: {}\".format(resp.status_code))\n    print(\"reason: {}\".format(resp.reason))\n    print(\"text: {}\".format(resp.text))\n    print(\"raise_for_status: {}\".format(resp.raise_for_status()))\n    print(\"elapsed: {}\".format(resp.elapsed))\n    print(\"headers: {}\".format(resp.headers))\n    print(\"payload: {}\".format(payload))\n    print(json.dumps(\n        json.loads(resp.content),\n        indent=4\n    ))\n    exit(1)\n# endregion\n\n# endregion\n\n#* get free ip\n#region get free ip\n\n# region prepare api call\napi_server_endpoint = \"\/api\/{}\/addresses\/first_free\/{}\".format(phpipam_app_id,phpipam_subnet_id)\nurl = \"https:\/\/{}:{}{}\".format(\n    api_server,\n    api_server_port,\n    api_server_endpoint\n)\nmethod = \"POST\"\nheaders = {\n    'Content-Type': 'application\/json',\n    'Accept': 'application\/json',\n    'token' : phpipam_token\n}\n\n# Compose the json payload\npayload = {\n    \"hostname\": hostname, \n    \"description\": hostname,\n    \"owner\": owner\n}\n# endregion\n\n# region make api call\n# make the API call and capture the results in the variable called \"resp\"\nprint(\"Making a {} API call to {}\".format(method, url))\nresp = process_request(url, method, username, username_secret, headers, payload)\n\n# deal with the result\/response\nif resp.ok:\n    print(\"Request was successful. Status code: {}\".format(resp.status_code))\n    print (\"IP {} was registered for host {} with owner {}\".format(json.loads(resp.content)['data'],hostname,owner))\n    print('vm_ip= {}'.format(json.loads(resp.content)['data']))\nelse:\n    # print the content of the response (which should have the error message)\n    print(\"Request failed!\")\n    print(\"status code: {}\".format(r.status_code))\n    print(\"reason: {}\".format(r.reason))\n    print(\"text: {}\".format(r.text))\n    print(\"raise_for_status: {}\".format(r.raise_for_status()))\n    print(\"elapsed: {}\".format(r.elapsed))\n    print(\"headers: {}\".format(r.headers))\n    print(\"payload: {}\".format(payload))\n    print(json.dumps(\n        json.loads(resp.content),\n        indent=4\n    ))\n    exit(1)\n# endregion\n\n# endregion\n\n#* revoke token\n# region get auth token\n\n# region prepare api call\n#! note that if your app security in php-ipam is set to 'none'\n#! you will have to change the port to 80 and url to http.\napi_server_endpoint = \"\/api\/{}\/user\".format(phpipam_app_id)\nurl = \"https:\/\/{}:{}{}\".format(\n    api_server,\n    api_server_port,\n    api_server_endpoint\n)\nmethod = \"DELETE\"\nheaders = {\n    'Content-Type': 'application\/json',\n    'Accept': 'application\/json',\n    'token' : phpipam_token\n}\n# endregion\n\n# region make api call\n# make the API call and capture the results in the variable called \"resp\"\nprint(\"Making a {} API call to {}\".format(method, url))\nresp = process_request(url, method, username, username_secret, headers)\n\n# deal with the result\/response\nif resp.ok:\n    print(\"Request was successful. Status code: {}\".format(resp.status_code))\n    print(\"Token was revoked\")\nelse:\n    # print the content of the response (which should have the error message)\n    print(\"Request failed!\")\n    print(\"status code: {}\".format(r.status_code))\n    print(\"reason: {}\".format(r.reason))\n    print(\"text: {}\".format(r.text))\n    print(\"raise_for_status: {}\".format(r.raise_for_status()))\n    print(\"elapsed: {}\".format(r.elapsed))\n    print(\"headers: {}\".format(r.headers))\n    print(\"payload: {}\".format(payload))\n    print(json.dumps(\n        json.loads(resp.content),\n        indent=4\n    ))\n    exit(1)\n# endregion\n\n# endregion\n","eval_variables":["vm_ip"],"eval_scope":"local","type":"","script_type":"static"},"timeout_secs":"0","type":"SET_VARIABLE","variable_list":[]}],"description":"","name":"AHVVM___pre_create___runbook","main_task_local_reference":{"kind":"app_task","name":"AHVVM___pre_create___dag"},"variable_list":[]},"name":"pre_action_create"},{"description":"","type":"fragment","critical":false,"runbook":{"task_definition_list":[{"target_any_local_reference":{"kind":"app_substrate","name":"AHVVM"},"retries":"0","description":"","child_tasks_local_reference_list":[{"kind":"app_task","name":"PhpIPAMReleaseIp"}],"name":"AHVVM___post_delete___dag","attrs":{"edges":[],"type":""},"timeout_secs":"0","type":"DAG","variable_list":[]},{"target_any_local_reference":{"kind":"app_substrate","name":"AHVVM"},"retries":"0","description":"","child_tasks_local_reference_list":[],"name":"PhpIPAMReleaseIp","attrs":{"script":"# region headers\n# escript-template v20190611 \/ stephane.bourdeaud@nutanix.com\n# * author:     stephane.bourdeaud@nutanix.com, igor.zecevic@nutanix.com\n# * version:    v2.0\/20210503 - cita-starter version\n# task_name:    PhpIPAMReleaseIp\n# description:  Given a phpIPAM server ip\/fqdn, a phpIPAM app id, an \n#               authentication token, a subnet id and an ip, releases \n#               the ip in ipam.\n# output vars:  <none>\n# endregion\n\n# region capture Calm variables\nusername = '@@{phpipam.username}@@'\nusername_secret = \"@@{phpipam.secret}@@\"\napi_server = \"@@{phpipam_ip}@@\"\nphpipam_app_id = \"@@{phpipam_app_id}@@\"\nip = \"@@{vm_ip}@@\"\nphpipam_subnet_id = \"@@{phpipam_subnet_id}@@\"\n# endregion\n\n# region prepare variables\napi_server_port = \"443\"\nsecure_calls=True\n# endregion\n\n# region API call function\nimport requests\n\ndef process_request(url, method, user, password, headers, payload=None, secure=secure_calls):\n    if payload is not None:\n        payload = json.dumps(payload)\n    \n    #configuring web request behavior\n    timeout=10\n    retries = 5\n    sleep_between_retries = 5\n    \n    while retries > 0:\n        try:\n\n            if method == 'POST':\n                    r = requests.post(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'DELETE':\n                r = requests.delete(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'GET':\n                r = requests.get(\n                    url,\n                    headers=headers,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PUT':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PATCH':\n                    r = requests.patch(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n        except requests.exceptions.HTTPError as e:\n            print (\"Http Error!\")\n            print(\"status code: {}\".format(r.status_code))\n            print(\"reason: {}\".format(r.reason))\n            print(\"text: {}\".format(r.text))\n            print(\"elapsed: {}\".format(r.elapsed))\n            print(\"headers: {}\".format(r.headers))\n            if payload is not None:\n                print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(r.content),\n                indent=4\n            ))\n            exit(r.status_code)\n        except requests.exceptions.ConnectionError as e:\n            print (\"Connection Error!\")\n            if retries == 1:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                exit(1)\n            else:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n            print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n            exit(1)\n        except requests.exceptions.Timeout as e:\n            print (\"Timeout Error!\")\n            if retries == 1:\n                raise Exception(e)\n            else:\n                print('Error! Code: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n        except requests.exceptions.RequestException as e:\n            print (\"Error!\")\n            exit(r.status_code)\n        break\n    \n    if r.ok:\n        return r\n    if r.status_code == 401:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        exit(r.status_code)\n    elif r.status_code == 500:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        exit(r.status_code)\n    else:\n        print(\"Request failed!\")\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        print(\"raise_for_status: {0}\".format(r.raise_for_status()))\n        print(\"elapsed: {0}\".format(r.elapsed))\n        print(\"headers: {0}\".format(r.headers))\n        if payload is not None:\n            print(\"payload: {0}\".format(payload))\n        print(json.dumps(\n            json.loads(r.content),\n            indent=4\n        ))\n        exit(r.status_code)\n\n# endregion\n\n\n#* get auth token\n# region get auth token\n\n# region prepare api call\n#! note that if your app security in php-ipam is set to 'none'\n#! you will have to change the port to 80 and url to http.\napi_server_endpoint = \"\/api\/{}\/user\".format(phpipam_app_id)\nurl = \"https:\/\/{}:{}{}\".format(\n    api_server,\n    api_server_port,\n    api_server_endpoint\n)\nmethod = \"POST\"\nheaders = {\n    'Content-Type': 'application\/json',\n    'Accept': 'application\/json'\n}\n# endregion\n\n# region make api call\n# make the API call and capture the results in the variable called \"resp\"\nprint(\"Making a {} API call to {}\".format(method, url))\nresp = process_request(url, method, username, username_secret, headers)\n\n# deal with the result\/response\nif resp.ok:\n    print(\"Request was successful. Status code: {}\".format(resp.status_code))\n    phpipam_token=json.loads(resp.content)['data']['token']\nelse:\n    # print the content of the response (which should have the error message)\n    print(\"Request failed!\")\n    print(\"status code: {}\".format(resp.status_code))\n    print(\"reason: {}\".format(resp.reason))\n    print(\"text: {}\".format(resp.text))\n    print(\"raise_for_status: {}\".format(resp.raise_for_status()))\n    print(\"elapsed: {}\".format(resp.elapsed))\n    print(\"headers: {}\".format(resp.headers))\n    print(\"payload: {}\".format(payload))\n    print(json.dumps(\n        json.loads(resp.content),\n        indent=4\n    ))\n    exit(1)\n# endregion\n\n# endregion\n\n#* release ip\n# region release ip\n\n# region prepare api call\n#! note that if your app security in php-ipam is set to 'none'\n#! you will have to change the port to 80 and url to http.\napi_server_endpoint = \"\/api\/{}\/addresses\/{}\/{}\/\".format(phpipam_app_id,ip,phpipam_subnet_id)\nurl = \"https:\/\/{}:{}{}\".format(\n    api_server,\n    api_server_port,\n    api_server_endpoint\n)\nmethod = \"DELETE\"\nheaders = {\n    'Content-Type': 'application\/json',\n    'Accept': 'application\/json',\n    'token' : phpipam_token\n}\n# endregion\n\n# region make api call\n# make the API call and capture the results in the variable called \"resp\"\nprint(\"Making a {} API call to {}\".format(method, url))\nresp = process_request(url, method, username, username_secret, headers)\n\n# deal with the result\/response\nif resp.ok:\n    print(\"Request was successful. Status code: {}\".format(resp.status_code))\n    print(\"IP address {} was released from subnet in ipam.\".format(ip))\nelse:\n    # print the content of the response (which should have the error message)\n    print(\"Request failed!\")\n    print(\"status code: {}\".format(resp.status_code))\n    print(\"reason: {}\".format(resp.reason))\n    print(\"text: {}\".format(resp.text))\n    print(\"raise_for_status: {}\".format(resp.raise_for_status()))\n    print(\"elapsed: {}\".format(resp.elapsed))\n    print(\"headers: {}\".format(resp.headers))\n    print(\"payload: {}\".format(payload))\n    print(json.dumps(\n        json.loads(resp.content),\n        indent=4\n    ))\n    exit(1)\n# endregion\n\n# endregion\n\n#* revoke token\n# region revoke auth token\n\n# region prepare api call\n#! note that if your app security in php-ipam is set to 'none'\n#! you will have to change the port to 80 and url to http.\napi_server_endpoint = \"\/api\/{}\/user\".format(phpipam_app_id)\nurl = \"https:\/\/{}:{}{}\".format(\n    api_server,\n    api_server_port,\n    api_server_endpoint\n)\nmethod = \"DELETE\"\nheaders = {\n    'Content-Type': 'application\/json',\n    'Accept': 'application\/json',\n    'token' : phpipam_token\n}\n# endregion\n\n# region make api call\n# make the API call and capture the results in the variable called \"resp\"\nprint(\"Making a {} API call to {}\".format(method, url))\nresp = process_request(url, method, username, username_secret, headers)\n\n# deal with the result\/response\nif resp.ok:\n    print(\"Request was successful. Status code: {}\".format(resp.status_code))\n    print(\"Token was revoked\")\nelse:\n    # print the content of the response (which should have the error message)\n    print(\"Request failed!\")\n    print(\"status code: {}\".format(resp.status_code))\n    print(\"reason: {}\".format(resp.reason))\n    print(\"text: {}\".format(resp.text))\n    print(\"raise_for_status: {}\".format(resp.raise_for_status()))\n    print(\"elapsed: {}\".format(resp.elapsed))\n    print(\"headers: {}\".format(resp.headers))\n    print(\"payload: {}\".format(payload))\n    print(json.dumps(\n        json.loads(resp.content),\n        indent=4\n    ))\n    exit(1)\n# endregion\n\n# endregion\n","type":"","command_line_args":"","exit_status":[],"script_type":"static"},"timeout_secs":"0","type":"EXEC","variable_list":[]}],"description":"","name":"AHVVM___post_delete___runbook","main_task_local_reference":{"kind":"app_task","name":"AHVVM___post_delete___dag"},"variable_list":[]},"name":"post_action_delete"}],"type":"AHV_VM","name":"AHVVM","readiness_probe":{"connection_type":"SSH","retries":"5","connection_protocol":"","connection_port":22,"address":"@@{platform.status.resources.nic_list[0].ip_endpoint_list[0].ip}@@","delay_secs":"180","disable_readiness_probe":false,"login_credential_local_reference":{"kind":"app_credential","name":"linux"}},"editables":{"create_spec":{"resources":{"nic_list":{"0":{"subnet_reference":true}},"serial_port_list":{},"num_vcpus_per_socket":true,"num_sockets":true,"memory_size_mib":true,"boot_config":true,"disk_list":{"2":{"disk_size_mib":true}}}}},"os_type":"Linux","create_spec":{"name":"@@{vm_name}@@","resources":{"nic_list":[{"nic_type":"NORMAL_NIC","ip_endpoint_list":[],"network_function_chain_reference":null,"network_function_nic_type":"INGRESS","mac_address":"","subnet_reference":{"kind":"subnet","type":"","name":"VLAN568","uuid":"d26a8da7-adfd-4870-b64d-d377f27ecbd2"},"type":""}],"serial_port_list":[],"guest_tools":null,"num_vcpus_per_socket":2,"num_sockets":1,"gpu_list":[],"memory_size_mib":2048,"parent_reference":null,"hardware_clock_timezone":"","guest_customization":{"cloud_init":{"meta_data":"","type":"","user_data":"#cloud-config\ndisable_root: False\ncloud_config_modules: \n  - resolv_conf\n\nhostname: @@{vm_name}@@\nfqdn: @@{vm_name}@@.@@{domain}@@\n\nusers:\n  - default\n  - name: @@{linux.username}@@\n    ssh-authorized-keys:\n      - @@{public_key}@@\n    sudo: ['ALL=(ALL) NOPASSWD:ALL']\n\nwrite_files:\n  - path: \/etc\/sysconfig\/network-scripts\/ifcfg-eth0\n    content: |\n      IPADDR=@@{vm_ip}@@\n      NETMASK=@@{subnet_mask}@@\n      GATEWAY=@@{gateway}@@\n      BOOTPROTO=static\n      ONBOOT=yes\n      DEVICE=eth0\nmanage_resolv_conf: true\nresolv_conf:\n  nameservers: ['@@{dns1}@@','@@{dns2}@@']\n  domain: '@@{domain}@@'\n  options:\n    attempts: 5\n    timeout: 15\n\nruncmd:\n  - [sudo, ifdown, eth0]\n  - [sudo, ifup, eth0]\n  - [sudo, systemctl, restart, network]\n  - [sudo, systemctl, mask, cloud-init-local, cloud-init, cloud-config, cloud-final]\n  - [eject]\n\npackage_upgrade: true\n\npower_state:\n  delay: \"+1\"\n  mode: reboot\n  message: Rebooting after cloud-init\n  timeout: 30\n  condition: True\n"},"type":"","sysprep":null},"power_state":"ON","type":"","account_uuid":"e2f4085b-937a-4741-8ae1-859ec0fbee89","boot_config":{"boot_device":{"type":"","disk_address":{"type":"","device_index":0,"adapter_type":"SCSI"}},"type":"","boot_type":"","mac_address":""},"disk_list":[{"data_source_reference":{"kind":"image","type":"","name":"pracdev-cita-calm-centos-7","uuid":"9f1dbed5-3601-49b3-ae9b-d00b995e869e"},"type":"","disk_size_mib":0,"volume_group_reference":null,"device_properties":{"type":"","disk_address":{"type":"","device_index":0,"adapter_type":"SCSI"},"device_type":"DISK"}},{"data_source_reference":null,"type":"","disk_size_mib":0,"volume_group_reference":null,"device_properties":{"type":"","disk_address":{"type":"","device_index":0,"adapter_type":"IDE"},"device_type":"CDROM"}},{"data_source_reference":null,"type":"","disk_size_mib":51200,"volume_group_reference":null,"device_properties":{"type":"","disk_address":{"type":"","device_index":1,"adapter_type":"SCSI"},"device_type":"DISK"}}]},"availability_zone_reference":null,"backup_policy":null,"type":"","cluster_reference":null,"categories":""},"variable_list":[]},{"description":"","action_list":[{"description":"","type":"fragment","critical":false,"runbook":{"task_definition_list":[{"target_any_local_reference":{"kind":"app_substrate","name":"vSphereVM"},"retries":"0","description":"","child_tasks_local_reference_list":[{"kind":"app_task","name":"PhpIPAMGetSubnetId"},{"kind":"app_task","name":"PhpIPAMGetSubnet"},{"kind":"app_task","name":"PhpIPAMGetFreeIp"}],"name":"vSphereVM___pre_create___dag","attrs":{"edges":[{"from_task_reference":{"kind":"app_task","name":"PhpIPAMGetSubnetId"},"edge_type":"user_defined","type":"","to_task_reference":{"kind":"app_task","name":"PhpIPAMGetSubnet"}},{"from_task_reference":{"kind":"app_task","name":"PhpIPAMGetSubnet"},"edge_type":"user_defined","type":"","to_task_reference":{"kind":"app_task","name":"PhpIPAMGetFreeIp"}}],"type":""},"timeout_secs":"0","type":"DAG","variable_list":[]},{"target_any_local_reference":{"kind":"app_substrate","name":"vSphereVM"},"retries":"0","description":"","child_tasks_local_reference_list":[],"name":"PhpIPAMGetSubnetId","attrs":{"exit_status":[],"script":"# region headers\n# escript-template v20190611 \/ stephane.bourdeaud@nutanix.com\n# * author:     stephane.bourdeaud@nutanix.com\n# * version:    v2.0\/20210503 - cita-starter version\n# task_name:    PhpIPAMGetSubnetId\n# description:  Given a phpIPAM server ip\/fqdn, app id, section id,\n#               token and a vlan id, return the phpIPAM subnet object id \n#               belonging to that VLAN. Assumes only one subnet per vlan.\n# output vars:  phpipam_subnet_id\n# endregion\n\n# region capture Calm variables\n# * Capture variables here. This makes sure Calm macros are not referenced\n# * anywhere else in order to improve maintainability.\nusername = '@@{phpipam.username}@@'\nusername_secret = \"@@{phpipam.secret}@@\"\napi_server = \"@@{phpipam_ip}@@\"\nphpipam_app_id = \"@@{phpipam_app_id}@@\"\nvlan_id = \"@@{vlan_id}@@\"\nphpipam_section_id = \"@@{phpipam_section_id}@@\"\n# endregion\n\n# region prepare variables\napi_server_port = \"443\"\nsecure_calls=True\n# endregion\n\n# region API call function\nimport requests\n\ndef process_request(url, method, user, password, headers, payload=None, secure=secure_calls):\n    if payload is not None:\n        payload = json.dumps(payload)\n    \n    #configuring web request behavior\n    timeout=10\n    retries = 5\n    sleep_between_retries = 5\n    \n    while retries > 0:\n        try:\n\n            if method == 'POST':\n                    r = requests.post(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'DELETE':\n                r = requests.delete(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'GET':\n                r = requests.get(\n                    url,\n                    headers=headers,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PUT':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PATCH':\n                    r = requests.patch(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n        except requests.exceptions.HTTPError as e:\n            print (\"Http Error!\")\n            print(\"status code: {}\".format(r.status_code))\n            print(\"reason: {}\".format(r.reason))\n            print(\"text: {}\".format(r.text))\n            print(\"elapsed: {}\".format(r.elapsed))\n            print(\"headers: {}\".format(r.headers))\n            if payload is not None:\n                print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(r.content),\n                indent=4\n            ))\n            exit(r.status_code)\n        except requests.exceptions.ConnectionError as e:\n            print (\"Connection Error!\")\n            if retries == 1:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                exit(1)\n            else:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n            print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n            exit(1)\n        except requests.exceptions.Timeout as e:\n            print (\"Timeout Error!\")\n            if retries == 1:\n                raise Exception(e)\n            else:\n                print('Error! Code: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n        except requests.exceptions.RequestException as e:\n            print (\"Error!\")\n            exit(r.status_code)\n        break\n    \n    if r.ok:\n        return r\n    if r.status_code == 401:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        exit(r.status_code)\n    elif r.status_code == 500:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        exit(r.status_code)\n    else:\n        print(\"Request failed!\")\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        print(\"raise_for_status: {0}\".format(r.raise_for_status()))\n        print(\"elapsed: {0}\".format(r.elapsed))\n        print(\"headers: {0}\".format(r.headers))\n        if payload is not None:\n            print(\"payload: {0}\".format(payload))\n        print(json.dumps(\n            json.loads(r.content),\n            indent=4\n        ))\n        exit(r.status_code)\n\n# endregion\n\n\n#* get auth token\n# region get auth token\n\n# region prepare api call\n#! note that if your app security in php-ipam is set to 'none'\n#! you will have to change the port to 80 and url to http.\napi_server_endpoint = \"\/api\/{}\/user\".format(phpipam_app_id)\nurl = \"https:\/\/{}:{}{}\".format(\n    api_server,\n    api_server_port,\n    api_server_endpoint\n)\nmethod = \"POST\"\nheaders = {\n    'Content-Type': 'application\/json',\n    'Accept': 'application\/json'\n}\n# endregion\n\n# region make api call\n# make the API call and capture the results in the variable called \"resp\"\nprint(\"Making a {} API call to {}\".format(method, url))\nresp = process_request(url, method, username, username_secret, headers)\n\n# deal with the result\/response\nif resp.ok:\n    print(\"Request was successful. Status code: {}\".format(resp.status_code))\n    phpipam_token=json.loads(resp.content)['data']['token']\nelse:\n    # print the content of the response (which should have the error message)\n    print(\"Request failed!\")\n    print(\"status code: {}\".format(resp.status_code))\n    print(\"reason: {}\".format(resp.reason))\n    print(\"text: {}\".format(resp.text))\n    print(\"raise_for_status: {}\".format(resp.raise_for_status()))\n    print(\"elapsed: {}\".format(resp.elapsed))\n    print(\"headers: {}\".format(resp.headers))\n    print(\"payload: {}\".format(payload))\n    print(json.dumps(\n        json.loads(resp.content),\n        indent=4\n    ))\n    exit(1)\n# endregion\n\n# endregion\n\n#* get phpIPAM vlan object id based on vlan id number\n#region GET phpIPAM vlan object id based on vlan id number\n# region prepare api call\n#! note that if your app security in php-ipam is set to 'none'\n#! you will have to change the port to 80 and url to http.\napi_server_endpoint = \"\/api\/{}\/vlan\/\".format(phpipam_app_id)\nurl = \"https:\/\/{}:{}{}\".format(\n    api_server,\n    api_server_port,\n    api_server_endpoint\n)\nmethod = \"GET\"\nheaders = {\n    'Content-Type': 'application\/json',\n    'Accept': 'application\/json',\n    'token' : phpipam_token\n}\n# endregion\n\n# region make api call\n# make the API call and capture the results in the variable called \"resp\"\nprint(\"Making a {} API call to {}\".format(method, url))\nresp = process_request(url, method, username, username_secret, headers)\n\n# deal with the result\/response\nif resp.ok:\n    found = False\n    for vlan in json.loads(resp.text)['data']:\n        if vlan['number'] == vlan_id:\n            print(\"Found phpIPAM vlan object {} with vlan number {}\".format(vlan['vlanId'],vlan_id))\n            phpipam_vlanId = vlan['vlanId']\n            found = True\n            break\n        else:\n            continue\n    if found == False:\n        print(\"Could not find any vlan with number {}\".format(vlan_id))\n        exit(1)\nelse:\n    # print the content of the response (which should have the error message)\n    print(\"Request failed!\")\n    print(\"status code: {}\".format(resp.status_code))\n    print(\"reason: {}\".format(resp.reason))\n    print(\"text: {}\".format(resp.text))\n    print(\"raise_for_status: {}\".format(resp.raise_for_status()))\n    print(\"elapsed: {}\".format(resp.elapsed))\n    print(\"headers: {}\".format(resp.headers))\n    print(\"payload: {}\".format(payload))\n    print(json.dumps(\n        json.loads(resp.content),\n        indent=4\n    ))\n    exit(1)\n# endregion\n\n#endregion\n\n#* get subnets and match with phpIPAM vlan object id\n#region GET subnets and match with phpIPAM vlan object id\n# region prepare api call\n#! note that if your app security in php-ipam is set to 'none'\n#! you will have to change the port to 80 and url to http.\napi_server_endpoint = \"\/api\/{}\/sections\/{}\/subnets\".format(phpipam_app_id,phpipam_section_id)\nurl = \"https:\/\/{}:{}{}\".format(\n    api_server,\n    api_server_port,\n    api_server_endpoint\n)\nmethod = \"GET\"\nheaders = {\n    'Content-Type': 'application\/json',\n    'Accept': 'application\/json',\n    'token' : phpipam_token\n}\n# endregion\n\n# region make api call\n# make the API call and capture the results in the variable called \"resp\"\nprint(\"Making a {} API call to {}\".format(method, url))\nresp = process_request(url, method, username, username_secret, headers)\n\n# deal with the result\/response\nif resp.ok:\n    print(\"Request was successful. Status code: {}\".format(resp.status_code))\n    #print('Response: {}'.format(json.dumps(json.loads(resp.content), indent=4)))\n    found = False\n    for subnet in json.loads(resp.text)['data']:\n        if subnet['vlanId'] == phpipam_vlanId:\n            print(\"phpipam_subnet_id= {}\".format(subnet['id']))\n            found = True\n            break\n        else:\n            continue\n    if found == False:\n        print(\"Could not find a subnet for vlan object id {} with vlan number {}!\".format(phpipam_vlanId,vlan_id))\n        exit(1)\nelse:\n    # print the content of the response (which should have the error message)\n    print(\"Request failed!\")\n    print(\"status code: {}\".format(resp.status_code))\n    print(\"reason: {}\".format(resp.reason))\n    print(\"text: {}\".format(resp.text))\n    print(\"raise_for_status: {}\".format(resp.raise_for_status()))\n    print(\"elapsed: {}\".format(resp.elapsed))\n    print(\"headers: {}\".format(resp.headers))\n    print(\"payload: {}\".format(payload))\n    print(json.dumps(\n        json.loads(resp.content),\n        indent=4\n    ))\n    exit(1)\n# endregion\n#endregion\n\n#* revoke token\n# region revoke auth token\n\n# region prepare api call\n#! note that if your app security in php-ipam is set to 'none'\n#! you will have to change the port to 80 and url to http.\napi_server_endpoint = \"\/api\/{}\/user\".format(phpipam_app_id)\nurl = \"https:\/\/{}:{}{}\".format(\n    api_server,\n    api_server_port,\n    api_server_endpoint\n)\nmethod = \"DELETE\"\nheaders = {\n    'Content-Type': 'application\/json',\n    'Accept': 'application\/json',\n    'token' : phpipam_token\n}\n# endregion\n\n# region make api call\n# make the API call and capture the results in the variable called \"resp\"\nprint(\"Making a {} API call to {}\".format(method, url))\nresp = process_request(url, method, username, username_secret, headers)\n\n# deal with the result\/response\nif resp.ok:\n    print(\"Request was successful. Status code: {}\".format(resp.status_code))\n    print(\"Token was revoked\")\nelse:\n    # print the content of the response (which should have the error message)\n    print(\"Request failed!\")\n    print(\"status code: {}\".format(resp.status_code))\n    print(\"reason: {}\".format(resp.reason))\n    print(\"text: {}\".format(resp.text))\n    print(\"raise_for_status: {}\".format(resp.raise_for_status()))\n    print(\"elapsed: {}\".format(resp.elapsed))\n    print(\"headers: {}\".format(resp.headers))\n    print(\"payload: {}\".format(payload))\n    print(json.dumps(\n        json.loads(resp.content),\n        indent=4\n    ))\n    exit(1)\n# endregion\n\n# endregion\n","eval_variables":["phpipam_subnet_id"],"eval_scope":"local","type":"","script_type":"static"},"timeout_secs":"0","type":"SET_VARIABLE","variable_list":[]},{"target_any_local_reference":{"kind":"app_substrate","name":"vSphereVM"},"retries":"0","description":"","child_tasks_local_reference_list":[],"name":"PhpIPAMGetSubnet","attrs":{"exit_status":[],"script":"# region headers\n# escript-template v20190611 \/ stephane.bourdeaud@nutanix.com\n# * author:     stephane.bourdeaud@nutanix.com\n# * version:    v2.0\/20210503 - cita-starter version\n# task_name:    PhpIPAMGetSubnet\n# description:  Given a php-ipam server ip\/fqdn, and a subnet id, return\n#               information about that subnet (mask, gateway, used IPs, \n#               total IPs, free IPs). It assumes the gateway and nameservers\n#               have been defined on the subnet.\n# output vars:  phpipam_subnet_mask, phpipam_subnet_bitmask,  \n#               phpipam_subnet_gateway, phpipam_subnet_total_ips,\n#               phpipam_subnet_nameservers\n# endregion\n\n# region capture Calm variables\n# * Capture variables here. This makes sure Calm macros are not referenced\n# * anywhere else in order to improve maintainability.\nusername = '@@{phpipam.username}@@'\nusername_secret = \"@@{phpipam.secret}@@\"\napi_server = \"@@{phpipam_ip}@@\"\nphpipam_app_id = \"@@{phpipam_app_id}@@\"\nphpipam_subnet_id = \"@@{phpipam_subnet_id}@@\"\n# endregion\n\n# region prepare variables\napi_server_port = \"443\"\nsecure_calls=True\n# endregion\n\n# region API call function\nimport requests\n\ndef process_request(url, method, user, password, headers, payload=None, secure=secure_calls):\n    if payload is not None:\n        payload = json.dumps(payload)\n    \n    #configuring web request behavior\n    timeout=10\n    retries = 5\n    sleep_between_retries = 5\n    \n    while retries > 0:\n        try:\n\n            if method == 'POST':\n                    r = requests.post(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'DELETE':\n                r = requests.delete(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'GET':\n                r = requests.get(\n                    url,\n                    headers=headers,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PUT':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PATCH':\n                    r = requests.patch(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n        except requests.exceptions.HTTPError as e:\n            print (\"Http Error!\")\n            print(\"status code: {}\".format(r.status_code))\n            print(\"reason: {}\".format(r.reason))\n            print(\"text: {}\".format(r.text))\n            print(\"elapsed: {}\".format(r.elapsed))\n            print(\"headers: {}\".format(r.headers))\n            if payload is not None:\n                print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(r.content),\n                indent=4\n            ))\n            exit(r.status_code)\n        except requests.exceptions.ConnectionError as e:\n            print (\"Connection Error!\")\n            if retries == 1:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                exit(1)\n            else:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n            print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n            exit(1)\n        except requests.exceptions.Timeout as e:\n            print (\"Timeout Error!\")\n            if retries == 1:\n                raise Exception(e)\n            else:\n                print('Error! Code: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n        except requests.exceptions.RequestException as e:\n            print (\"Error!\")\n            exit(r.status_code)\n        break\n    \n    if r.ok:\n        return r\n    if r.status_code == 401:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        exit(r.status_code)\n    elif r.status_code == 500:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        exit(r.status_code)\n    else:\n        print(\"Request failed!\")\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        print(\"raise_for_status: {0}\".format(r.raise_for_status()))\n        print(\"elapsed: {0}\".format(r.elapsed))\n        print(\"headers: {0}\".format(r.headers))\n        if payload is not None:\n            print(\"payload: {0}\".format(payload))\n        print(json.dumps(\n            json.loads(r.content),\n            indent=4\n        ))\n        exit(r.status_code)\n\n# endregion\n\n\n#* get auth token\n# region get auth token\n\n# region prepare api call\n#! note that if your app security in php-ipam is set to 'none'\n#! you will have to change the port to 80 and url to http.\napi_server_endpoint = \"\/api\/{}\/user\".format(phpipam_app_id)\nurl = \"https:\/\/{}:{}{}\".format(\n    api_server,\n    api_server_port,\n    api_server_endpoint\n)\nmethod = \"POST\"\nheaders = {\n    'Content-Type': 'application\/json',\n    'Accept': 'application\/json'\n}\n# endregion\n\n# region make api call\n# make the API call and capture the results in the variable called \"resp\"\nprint(\"Making a {} API call to {}\".format(method, url))\nresp = process_request(url, method, username, username_secret, headers)\n\n# deal with the result\/response\nif resp.ok:\n    print(\"Request was successful. Status code: {}\".format(resp.status_code))\n    phpipam_token=json.loads(resp.content)['data']['token']\nelse:\n    # print the content of the response (which should have the error message)\n    print(\"Request failed!\")\n    print(\"status code: {}\".format(resp.status_code))\n    print(\"reason: {}\".format(resp.reason))\n    print(\"text: {}\".format(resp.text))\n    print(\"raise_for_status: {}\".format(resp.raise_for_status()))\n    print(\"elapsed: {}\".format(resp.elapsed))\n    print(\"headers: {}\".format(resp.headers))\n    print(\"payload: {}\".format(payload))\n    print(json.dumps(\n        json.loads(resp.content),\n        indent=4\n    ))\n    exit(1)\n# endregion\n\n# endregion\n\n#* get subnet details\n#region get subnet details\n\n# region prepare api call\n#! note that if your app security in php-ipam is set to 'none'\n#! you will have to change the port to 80 and url to http.\napi_server_endpoint = \"\/api\/{}\/subnets\/{}\/\".format(phpipam_app_id,phpipam_subnet_id)\nurl = \"https:\/\/{}:{}{}\".format(\n    api_server,\n    api_server_port,\n    api_server_endpoint\n)\nmethod = \"GET\"\nheaders = {\n    'Content-Type': 'application\/json',\n    'Accept': 'application\/json',\n    'token' : phpipam_token\n}\n# endregion\n\n# region make api call\n# make the API call and capture the results in the variable called \"resp\"\nprint(\"Making a {} API call to {}\".format(method, url))\nresp = process_request(url, method, username, username_secret, headers)\n\n# deal with the result\/response\nif resp.ok:\n    print(\"Request was successful. Status code: {}\".format(resp.status_code))\n    #print('Response: {}'.format(json.dumps(json.loads(resp.content), indent=4)))\n    dns_servers=json.loads(resp.content)['data']['nameservers']['namesrv1']\n    dns_servers=dns_servers.split(';')\n    print(\"subnet_mask= {}\".format(json.loads(resp.content)['data']['calculation']['Subnet netmask']))\n    print(\"subnet_mask_bits= {}\".format(json.loads(resp.content)['data']['calculation']['Subnet bitmask']))\n    print(\"gateway= {}\".format(json.loads(resp.content)['data']['gateway']['ip_addr']))\n    print(\"dns1= {}\".format(dns_servers[0]))\n    print(\"dns2= {}\".format(dns_servers[1]))\nelse:\n    # print the content of the response (which should have the error message)\n    print(\"Request failed!\")\n    print(\"status code: {}\".format(resp.status_code))\n    print(\"reason: {}\".format(resp.reason))\n    print(\"text: {}\".format(resp.text))\n    print(\"raise_for_status: {}\".format(resp.raise_for_status()))\n    print(\"elapsed: {}\".format(resp.elapsed))\n    print(\"headers: {}\".format(resp.headers))\n    print(\"payload: {}\".format(payload))\n    print(json.dumps(\n        json.loads(resp.content),\n        indent=4\n    ))\n    exit(1)\n# endregion\n\n# endregion\n\n#* revoke token\n# region revoke auth token\n\n# region prepare api call\n#! note that if your app security in php-ipam is set to 'none'\n#! you will have to change the port to 80 and url to http.\napi_server_endpoint = \"\/api\/{}\/user\".format(phpipam_app_id)\nurl = \"https:\/\/{}:{}{}\".format(\n    api_server,\n    api_server_port,\n    api_server_endpoint\n)\nmethod = \"DELETE\"\nheaders = {\n    'Content-Type': 'application\/json',\n    'Accept': 'application\/json',\n    'token' : phpipam_token\n}\n# endregion\n\n# region make api call\n# make the API call and capture the results in the variable called \"resp\"\nprint(\"Making a {} API call to {}\".format(method, url))\nresp = process_request(url, method, username, username_secret, headers)\n\n# deal with the result\/response\nif resp.ok:\n    print(\"Request was successful. Status code: {}\".format(resp.status_code))\n    print(\"Token was revoked\")\nelse:\n    # print the content of the response (which should have the error message)\n    print(\"Request failed!\")\n    print(\"status code: {}\".format(resp.status_code))\n    print(\"reason: {}\".format(resp.reason))\n    print(\"text: {}\".format(resp.text))\n    print(\"raise_for_status: {}\".format(resp.raise_for_status()))\n    print(\"elapsed: {}\".format(resp.elapsed))\n    print(\"headers: {}\".format(resp.headers))\n    print(\"payload: {}\".format(payload))\n    print(json.dumps(\n        json.loads(resp.content),\n        indent=4\n    ))\n    exit(1)\n# endregion\n\n# endregion\n","eval_variables":["phpipam_subnet_bitmask","subnet_mask","gateway","phpipam_subnet_total_ips","dns1","dns2"],"eval_scope":"local","type":"","script_type":"static"},"timeout_secs":"0","type":"SET_VARIABLE","variable_list":[]},{"target_any_local_reference":{"kind":"app_substrate","name":"vSphereVM"},"retries":"0","description":"","child_tasks_local_reference_list":[],"name":"PhpIPAMGetFreeIp","attrs":{"exit_status":[],"script":"# region headers\n# escript-template v20190611 \/ stephane.bourdeaud@nutanix.com\n# TODO Fill in this section with your information\n# * author:     stephane.bourdeaud@nutanix.com, igor.zecevic@nutanix.com\n# * version:    v2.1\/20210504 - cita-starter version\n# task_name:    PhpIPAMGetFreeIp\n# description:  Given a phpIPAM server ip\/fqdn, a phpIPAM app id, a token\n#               and a subnet id, return the first available IP address in \n#               that subnet. The current VM name and Calm user will be used\n#               for ip registration with ipam.               \n# outputvars:   phpipam_free_ip\n# endregion\n\n# region capture Calm variables\nusername = '@@{phpipam.username}@@'\nusername_secret = \"@@{phpipam.secret}@@\"\napi_server = \"@@{phpipam_ip}@@\"\nphpipam_app_id = \"@@{phpipam_app_id}@@\"\nphpipam_subnet_id = \"@@{phpipam_subnet_id}@@\"\nhostname = \"@@{vm_name}@@.@@{domain}@@\"\nowner = \"@@{calm_username}@@\" #* this is a built-in Calm macro which returns the Calm user username\n# endregion\n\n# region prepare variables\napi_server_port = \"443\"\nsecure_calls=True\n# endregion\n\n# region API call function\nimport requests\n\ndef process_request(url, method, user, password, headers, payload=None, secure=secure_calls):\n    if payload is not None:\n        payload = json.dumps(payload)\n    \n    #configuring web request behavior\n    timeout=10\n    retries = 5\n    sleep_between_retries = 5\n    \n    while retries > 0:\n        try:\n\n            if method == 'POST':\n                    r = requests.post(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'DELETE':\n                r = requests.delete(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'GET':\n                r = requests.get(\n                    url,\n                    headers=headers,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PUT':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PATCH':\n                    r = requests.patch(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n        except requests.exceptions.HTTPError as e:\n            print (\"Http Error!\")\n            print(\"status code: {}\".format(r.status_code))\n            print(\"reason: {}\".format(r.reason))\n            print(\"text: {}\".format(r.text))\n            print(\"elapsed: {}\".format(r.elapsed))\n            print(\"headers: {}\".format(r.headers))\n            if payload is not None:\n                print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(r.content),\n                indent=4\n            ))\n            exit(r.status_code)\n        except requests.exceptions.ConnectionError as e:\n            print (\"Connection Error!\")\n            if retries == 1:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                exit(1)\n            else:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n            print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n            exit(1)\n        except requests.exceptions.Timeout as e:\n            print (\"Timeout Error!\")\n            if retries == 1:\n                raise Exception(e)\n            else:\n                print('Error! Code: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n        except requests.exceptions.RequestException as e:\n            print (\"Error!\")\n            exit(r.status_code)\n        break\n    \n    if r.ok:\n        return r\n    if r.status_code == 401:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        exit(r.status_code)\n    elif r.status_code == 500:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        exit(r.status_code)\n    else:\n        print(\"Request failed!\")\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        print(\"raise_for_status: {0}\".format(r.raise_for_status()))\n        print(\"elapsed: {0}\".format(r.elapsed))\n        print(\"headers: {0}\".format(r.headers))\n        if payload is not None:\n            print(\"payload: {0}\".format(payload))\n        print(json.dumps(\n            json.loads(r.content),\n            indent=4\n        ))\n        exit(r.status_code)\n        \n# endregion\n\n\n#* get auth token\n# region get auth token\n\n# region prepare api call\n#! note that if your app security in php-ipam is set to 'none'\n#! you will have to change the port to 80 and url to http.\napi_server_endpoint = \"\/api\/{}\/user\".format(phpipam_app_id)\nurl = \"https:\/\/{}:{}{}\".format(\n    api_server,\n    api_server_port,\n    api_server_endpoint\n)\nmethod = \"POST\"\nheaders = {\n    'Content-Type': 'application\/json',\n    'Accept': 'application\/json'\n}\n# endregion\n\n# region make api call\n# make the API call and capture the results in the variable called \"resp\"\nprint(\"Making a {} API call to {}\".format(method, url))\nresp = process_request(url, method, username, username_secret, headers)\n\n# deal with the result\/response\nif resp.ok:\n    print(\"Request was successful. Status code: {}\".format(resp.status_code))\n    phpipam_token=json.loads(resp.content)['data']['token']\nelse:\n    # print the content of the response (which should have the error message)\n    print(\"Request failed!\")\n    print(\"status code: {}\".format(resp.status_code))\n    print(\"reason: {}\".format(resp.reason))\n    print(\"text: {}\".format(resp.text))\n    print(\"raise_for_status: {}\".format(resp.raise_for_status()))\n    print(\"elapsed: {}\".format(resp.elapsed))\n    print(\"headers: {}\".format(resp.headers))\n    print(\"payload: {}\".format(payload))\n    print(json.dumps(\n        json.loads(resp.content),\n        indent=4\n    ))\n    exit(1)\n# endregion\n\n# endregion\n\n#* get free ip\n#region get free ip\n\n# region prepare api call\napi_server_endpoint = \"\/api\/{}\/addresses\/first_free\/{}\".format(phpipam_app_id,phpipam_subnet_id)\nurl = \"https:\/\/{}:{}{}\".format(\n    api_server,\n    api_server_port,\n    api_server_endpoint\n)\nmethod = \"POST\"\nheaders = {\n    'Content-Type': 'application\/json',\n    'Accept': 'application\/json',\n    'token' : phpipam_token\n}\n\n# Compose the json payload\npayload = {\n    \"hostname\": hostname, \n    \"description\": hostname,\n    \"owner\": owner\n}\n# endregion\n\n# region make api call\n# make the API call and capture the results in the variable called \"resp\"\nprint(\"Making a {} API call to {}\".format(method, url))\nresp = process_request(url, method, username, username_secret, headers, payload)\n\n# deal with the result\/response\nif resp.ok:\n    print(\"Request was successful. Status code: {}\".format(resp.status_code))\n    print (\"IP {} was registered for host {} with owner {}\".format(json.loads(resp.content)['data'],hostname,owner))\n    print('vm_ip= {}'.format(json.loads(resp.content)['data']))\nelse:\n    # print the content of the response (which should have the error message)\n    print(\"Request failed!\")\n    print(\"status code: {}\".format(r.status_code))\n    print(\"reason: {}\".format(r.reason))\n    print(\"text: {}\".format(r.text))\n    print(\"raise_for_status: {}\".format(r.raise_for_status()))\n    print(\"elapsed: {}\".format(r.elapsed))\n    print(\"headers: {}\".format(r.headers))\n    print(\"payload: {}\".format(payload))\n    print(json.dumps(\n        json.loads(resp.content),\n        indent=4\n    ))\n    exit(1)\n# endregion\n\n# endregion\n\n#* revoke token\n# region get auth token\n\n# region prepare api call\n#! note that if your app security in php-ipam is set to 'none'\n#! you will have to change the port to 80 and url to http.\napi_server_endpoint = \"\/api\/{}\/user\".format(phpipam_app_id)\nurl = \"https:\/\/{}:{}{}\".format(\n    api_server,\n    api_server_port,\n    api_server_endpoint\n)\nmethod = \"DELETE\"\nheaders = {\n    'Content-Type': 'application\/json',\n    'Accept': 'application\/json',\n    'token' : phpipam_token\n}\n# endregion\n\n# region make api call\n# make the API call and capture the results in the variable called \"resp\"\nprint(\"Making a {} API call to {}\".format(method, url))\nresp = process_request(url, method, username, username_secret, headers)\n\n# deal with the result\/response\nif resp.ok:\n    print(\"Request was successful. Status code: {}\".format(resp.status_code))\n    print(\"Token was revoked\")\nelse:\n    # print the content of the response (which should have the error message)\n    print(\"Request failed!\")\n    print(\"status code: {}\".format(r.status_code))\n    print(\"reason: {}\".format(r.reason))\n    print(\"text: {}\".format(r.text))\n    print(\"raise_for_status: {}\".format(r.raise_for_status()))\n    print(\"elapsed: {}\".format(r.elapsed))\n    print(\"headers: {}\".format(r.headers))\n    print(\"payload: {}\".format(payload))\n    print(json.dumps(\n        json.loads(resp.content),\n        indent=4\n    ))\n    exit(1)\n# endregion\n\n# endregion\n","eval_variables":["vm_ip"],"eval_scope":"local","type":"","script_type":"static"},"timeout_secs":"0","type":"SET_VARIABLE","variable_list":[]}],"description":"","name":"vSphereVM___pre_create___runbook","main_task_local_reference":{"kind":"app_task","name":"vSphereVM___pre_create___dag"},"variable_list":[]},"name":"pre_action_create"},{"description":"","type":"fragment","critical":false,"runbook":{"task_definition_list":[{"target_any_local_reference":{"kind":"app_substrate","name":"vSphereVM"},"retries":"0","description":"","child_tasks_local_reference_list":[{"kind":"app_task","name":"PhpIPAMReleaseIp"}],"name":"vSphereVM___post_delete___dag","attrs":{"edges":[],"type":""},"timeout_secs":"0","type":"DAG","variable_list":[]},{"target_any_local_reference":{"kind":"app_substrate","name":"vSphereVM"},"retries":"0","description":"","child_tasks_local_reference_list":[],"name":"PhpIPAMReleaseIp","attrs":{"script":"# region headers\n# escript-template v20190611 \/ stephane.bourdeaud@nutanix.com\n# * author:     stephane.bourdeaud@nutanix.com, igor.zecevic@nutanix.com\n# * version:    v2.0\/20210503 - cita-starter version\n# task_name:    PhpIPAMReleaseIp\n# description:  Given a phpIPAM server ip\/fqdn, a phpIPAM app id, an \n#               authentication token, a subnet id and an ip, releases \n#               the ip in ipam.\n# output vars:  <none>\n# endregion\n\n# region capture Calm variables\nusername = '@@{phpipam.username}@@'\nusername_secret = \"@@{phpipam.secret}@@\"\napi_server = \"@@{phpipam_ip}@@\"\nphpipam_app_id = \"@@{phpipam_app_id}@@\"\nip = \"@@{vm_ip}@@\"\nphpipam_subnet_id = \"@@{phpipam_subnet_id}@@\"\n# endregion\n\n# region prepare variables\napi_server_port = \"443\"\nsecure_calls=True\n# endregion\n\n# region API call function\nimport requests\n\ndef process_request(url, method, user, password, headers, payload=None, secure=secure_calls):\n    if payload is not None:\n        payload = json.dumps(payload)\n    \n    #configuring web request behavior\n    timeout=10\n    retries = 5\n    sleep_between_retries = 5\n    \n    while retries > 0:\n        try:\n\n            if method == 'POST':\n                    r = requests.post(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'DELETE':\n                r = requests.delete(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'GET':\n                r = requests.get(\n                    url,\n                    headers=headers,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PUT':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PATCH':\n                    r = requests.patch(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n        except requests.exceptions.HTTPError as e:\n            print (\"Http Error!\")\n            print(\"status code: {}\".format(r.status_code))\n            print(\"reason: {}\".format(r.reason))\n            print(\"text: {}\".format(r.text))\n            print(\"elapsed: {}\".format(r.elapsed))\n            print(\"headers: {}\".format(r.headers))\n            if payload is not None:\n                print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(r.content),\n                indent=4\n            ))\n            exit(r.status_code)\n        except requests.exceptions.ConnectionError as e:\n            print (\"Connection Error!\")\n            if retries == 1:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                exit(1)\n            else:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n            print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n            exit(1)\n        except requests.exceptions.Timeout as e:\n            print (\"Timeout Error!\")\n            if retries == 1:\n                raise Exception(e)\n            else:\n                print('Error! Code: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n        except requests.exceptions.RequestException as e:\n            print (\"Error!\")\n            exit(r.status_code)\n        break\n    \n    if r.ok:\n        return r\n    if r.status_code == 401:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        exit(r.status_code)\n    elif r.status_code == 500:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        exit(r.status_code)\n    else:\n        print(\"Request failed!\")\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        print(\"raise_for_status: {0}\".format(r.raise_for_status()))\n        print(\"elapsed: {0}\".format(r.elapsed))\n        print(\"headers: {0}\".format(r.headers))\n        if payload is not None:\n            print(\"payload: {0}\".format(payload))\n        print(json.dumps(\n            json.loads(r.content),\n            indent=4\n        ))\n        exit(r.status_code)\n\n# endregion\n\n\n#* get auth token\n# region get auth token\n\n# region prepare api call\n#! note that if your app security in php-ipam is set to 'none'\n#! you will have to change the port to 80 and url to http.\napi_server_endpoint = \"\/api\/{}\/user\".format(phpipam_app_id)\nurl = \"https:\/\/{}:{}{}\".format(\n    api_server,\n    api_server_port,\n    api_server_endpoint\n)\nmethod = \"POST\"\nheaders = {\n    'Content-Type': 'application\/json',\n    'Accept': 'application\/json'\n}\n# endregion\n\n# region make api call\n# make the API call and capture the results in the variable called \"resp\"\nprint(\"Making a {} API call to {}\".format(method, url))\nresp = process_request(url, method, username, username_secret, headers)\n\n# deal with the result\/response\nif resp.ok:\n    print(\"Request was successful. Status code: {}\".format(resp.status_code))\n    phpipam_token=json.loads(resp.content)['data']['token']\nelse:\n    # print the content of the response (which should have the error message)\n    print(\"Request failed!\")\n    print(\"status code: {}\".format(resp.status_code))\n    print(\"reason: {}\".format(resp.reason))\n    print(\"text: {}\".format(resp.text))\n    print(\"raise_for_status: {}\".format(resp.raise_for_status()))\n    print(\"elapsed: {}\".format(resp.elapsed))\n    print(\"headers: {}\".format(resp.headers))\n    print(\"payload: {}\".format(payload))\n    print(json.dumps(\n        json.loads(resp.content),\n        indent=4\n    ))\n    exit(1)\n# endregion\n\n# endregion\n\n#* release ip\n# region release ip\n\n# region prepare api call\n#! note that if your app security in php-ipam is set to 'none'\n#! you will have to change the port to 80 and url to http.\napi_server_endpoint = \"\/api\/{}\/addresses\/{}\/{}\/\".format(phpipam_app_id,ip,phpipam_subnet_id)\nurl = \"https:\/\/{}:{}{}\".format(\n    api_server,\n    api_server_port,\n    api_server_endpoint\n)\nmethod = \"DELETE\"\nheaders = {\n    'Content-Type': 'application\/json',\n    'Accept': 'application\/json',\n    'token' : phpipam_token\n}\n# endregion\n\n# region make api call\n# make the API call and capture the results in the variable called \"resp\"\nprint(\"Making a {} API call to {}\".format(method, url))\nresp = process_request(url, method, username, username_secret, headers)\n\n# deal with the result\/response\nif resp.ok:\n    print(\"Request was successful. Status code: {}\".format(resp.status_code))\n    print(\"IP address {} was released from subnet in ipam.\".format(ip))\nelse:\n    # print the content of the response (which should have the error message)\n    print(\"Request failed!\")\n    print(\"status code: {}\".format(resp.status_code))\n    print(\"reason: {}\".format(resp.reason))\n    print(\"text: {}\".format(resp.text))\n    print(\"raise_for_status: {}\".format(resp.raise_for_status()))\n    print(\"elapsed: {}\".format(resp.elapsed))\n    print(\"headers: {}\".format(resp.headers))\n    print(\"payload: {}\".format(payload))\n    print(json.dumps(\n        json.loads(resp.content),\n        indent=4\n    ))\n    exit(1)\n# endregion\n\n# endregion\n\n#* revoke token\n# region revoke auth token\n\n# region prepare api call\n#! note that if your app security in php-ipam is set to 'none'\n#! you will have to change the port to 80 and url to http.\napi_server_endpoint = \"\/api\/{}\/user\".format(phpipam_app_id)\nurl = \"https:\/\/{}:{}{}\".format(\n    api_server,\n    api_server_port,\n    api_server_endpoint\n)\nmethod = \"DELETE\"\nheaders = {\n    'Content-Type': 'application\/json',\n    'Accept': 'application\/json',\n    'token' : phpipam_token\n}\n# endregion\n\n# region make api call\n# make the API call and capture the results in the variable called \"resp\"\nprint(\"Making a {} API call to {}\".format(method, url))\nresp = process_request(url, method, username, username_secret, headers)\n\n# deal with the result\/response\nif resp.ok:\n    print(\"Request was successful. Status code: {}\".format(resp.status_code))\n    print(\"Token was revoked\")\nelse:\n    # print the content of the response (which should have the error message)\n    print(\"Request failed!\")\n    print(\"status code: {}\".format(resp.status_code))\n    print(\"reason: {}\".format(resp.reason))\n    print(\"text: {}\".format(resp.text))\n    print(\"raise_for_status: {}\".format(resp.raise_for_status()))\n    print(\"elapsed: {}\".format(resp.elapsed))\n    print(\"headers: {}\".format(resp.headers))\n    print(\"payload: {}\".format(payload))\n    print(json.dumps(\n        json.loads(resp.content),\n        indent=4\n    ))\n    exit(1)\n# endregion\n\n# endregion\n","type":"","command_line_args":"","exit_status":[],"script_type":"static"},"timeout_secs":"0","type":"EXEC","variable_list":[]}],"description":"","name":"vSphereVM___post_delete___runbook","main_task_local_reference":{"kind":"app_task","name":"vSphereVM___post_delete___dag"},"variable_list":[]},"name":"post_action_delete"}],"type":"VMWARE_VM","name":"vSphereVM","readiness_probe":{"connection_type":"SSH","retries":"5","connection_protocol":"","connection_port":22,"address":"@@{platform.ipAddressList[0]}@@","delay_secs":"180","disable_readiness_probe":false,"login_credential_local_reference":{"kind":"app_credential","name":"linux"}},"editables":{"create_spec":{"folder":{},"resources":{"template_nic_list":{"0":{"net_name":true}},"num_vcpus_per_socket":true,"num_sockets":true,"controller_list":{},"memory_size_mib":true,"guest_customization":{"windows_data":{"timezone":true}},"disk_list":{"0":{"disk_size_mb":true}}}}},"os_type":"Linux","create_spec":{"compute_drs_mode":true,"name":"@@{vm_name}@@","type":"PROVISION_VMWARE_VM","drs_mode":true,"cluster":"ROCKET","host":"","resources":{"nic_list":[],"template_disk_list":[{"disk_size_mb":16384,"is_deleted":false,"disk_mode":"persistent","device_slot":0,"adapter_type":"SCSI","iso_path":"","location":"ds:\/\/\/vmfs\/volumes\/be77b032-1ec18851\/","key":2000,"controller_key":1000,"disk_type":"disk","type":""}],"template_nic_list":[{"nic_type":"vmxnet3","is_deleted":false,"net_name":"key-vim.host.PortGroup-568","key":4000,"type":""}],"num_sockets":1,"num_vcpus_per_socket":1,"memory_hot_plug":false,"template_controller_list":[{"controller_type":"ParaVirtualSCSIController","type":"","bus_sharing":"noSharing","is_deleted":false,"key":1000}],"controller_list":[{"controller_type":"ParaVirtualSCSIController","type":"","bus_sharing":"noSharing","key":1001}],"memory_size_mib":2048,"power_state":"poweron","cpu_hot_add":false,"guest_customization":{"type":"","cloud_init":"#cloud-config\ndisable_root: False\ncloud_config_modules: \n  - resolv_conf\nhostname: @@{vm_name}@@\nfqdn: @@{vm_name}@@.@@{domain}@@\nusers:\n  - default\n  - name: @@{linux.username}@@\n    ssh-authorized-keys:\n      - @@{public_key}@@\n    sudo: ['ALL=(ALL) NOPASSWD:ALL']\nwrite_files:\n  - path: \/etc\/sysconfig\/network-scripts\/ifcfg-ens192\n    content: |\n      IPADDR=@@{vm_ip}@@\n      NETMASK=@@{subnet_mask}@@\n      GATEWAY=@@{gateway}@@\n      BOOTPROTO=static\n      ONBOOT=yes\n      DEVICE=ens192\nmanage_resolv_conf: true\nresolv_conf:\n  nameservers: ['@@{dns1}@@','@@{dns2}@@']\n  domain: '@@{domain}@@'\n  options:\n    attempts: 5\n    timeout: 15\nruncmd:\n  - [sudo, ifdown, eth0]\n  - [sudo, ifup, eth0]\n  - [sudo, systemctl, restart, network]\n  - [sudo, systemctl, mask, cloud-init-local, cloud-init, cloud-config, cloud-final]\n  - [eject]\npackage_upgrade: true\npower_state:\n  delay: \"+1\"\n  mode: reboot\n  message: Rebooting after cloud-init\n  timeout: 30\n  condition: True\n","customization_type":"GUEST_OS_LINUX","customization_name":""},"tag_list":[{"type":"","tag_id":"urn:vmomi:InventoryServiceTag:3b455b63-7927-4336-8186-d4e0bf2d976f:GLOBAL"}],"type":"","account_uuid":"fd98c355-7f48-49a1-c802-339a702a4292","disk_list":[{"disk_size_mb":51200,"disk_mode":"persistent","device_slot":0,"adapter_type":"SCSI","iso_path":"","location":"","controller_key":1001,"disk_type":"disk","type":""}]},"template":"503cec9b-c267-1da4-d12e-f5806349c6a6","datastore":"","storage_drs_mode":true,"storage_pod":"RocketStorage","folder":{"type":"","existing_path":"pracdev-cita","new_path":"","delete_empty_folder":false},"clone_is_template":false},"variable_list":[]}],"credential_definition_list":[{"username":"centos","description":"","type":"KEY","secret":{"attrs":{"is_secret_modified":false,"secret_reference":{}}},"name":"linux","editables":{"username":true,"secret":true}},{"username":"root","description":"","type":"PASSWORD","secret":{"attrs":{"is_secret_modified":false,"secret_reference":{}}},"name":"root"},{"username":"sbourdeaud@gso.lab","description":"","type":"PASSWORD","secret":{"attrs":{"is_secret_modified":false,"secret_reference":{}}},"name":"prism_central"},{"username":"sbourdeaud@gso.lab","description":"","type":"PASSWORD","secret":{"attrs":{"is_secret_modified":false,"secret_reference":{}}},"name":"vcenter"},{"username":"sbourdeaud","description":"","type":"PASSWORD","secret":{"attrs":{"is_secret_modified":false,"secret_reference":{}}},"name":"phpipam"}],"package_definition_list":[{"description":"","action_list":[],"type":"CUSTOM","service_local_reference_list":[{"kind":"app_service","name":"Linux"}],"name":"AHV_Package","version":"","options":{"install_runbook":{"task_definition_list":[{"target_any_local_reference":{"kind":"app_service","name":"Linux"},"retries":"0","description":"","child_tasks_local_reference_list":[{"kind":"app_task","name":"DisableSelinux"},{"kind":"app_task","name":"InitializeDataDisk"},{"kind":"app_task","name":"ApplyLinuxUpdates"},{"kind":"app_task","name":"PcMountNgt"},{"kind":"app_task","name":"Wait20"},{"kind":"app_task","name":"InstallNgt"},{"kind":"app_task","name":"PcEnableNewNgt"}],"name":"AHV_Package___install___dag","attrs":{"edges":[{"from_task_reference":{"kind":"app_task","name":"DisableSelinux"},"edge_type":"user_defined","type":"","to_task_reference":{"kind":"app_task","name":"InitializeDataDisk"}},{"from_task_reference":{"kind":"app_task","name":"InitializeDataDisk"},"edge_type":"user_defined","type":"","to_task_reference":{"kind":"app_task","name":"ApplyLinuxUpdates"}},{"from_task_reference":{"kind":"app_task","name":"ApplyLinuxUpdates"},"edge_type":"user_defined","type":"","to_task_reference":{"kind":"app_task","name":"PcMountNgt"}},{"from_task_reference":{"kind":"app_task","name":"PcMountNgt"},"edge_type":"user_defined","type":"","to_task_reference":{"kind":"app_task","name":"Wait20"}},{"from_task_reference":{"kind":"app_task","name":"Wait20"},"edge_type":"user_defined","type":"","to_task_reference":{"kind":"app_task","name":"InstallNgt"}},{"from_task_reference":{"kind":"app_task","name":"InstallNgt"},"edge_type":"user_defined","type":"","to_task_reference":{"kind":"app_task","name":"PcEnableNewNgt"}}],"type":""},"timeout_secs":"0","type":"DAG","variable_list":[]},{"target_any_local_reference":{"kind":"app_service","name":"Linux"},"retries":"0","description":"","child_tasks_local_reference_list":[],"name":"DisableSelinux","attrs":{"exit_status":[],"script":"#!\/bin\/bash\n\n# region headers\n# * author:     stephane.bourdeaud@nutanix.com\n# * version:    v1.0\/20210504 - cita-starter version\n# task_name:    DisableSelinux\n# description:  disables enforcement of selinux policy.               \n# output vars:  none\n# dependencies: none\n# endregion\n\nsudo hostnamectl set-hostname --static @@{vm_name}@@\necho \"@@{address}@@  @@{vm_name}@@.@@{domain}@@ @@{vm_name}@@\" | sudo tee -a \/etc\/hosts\n\n#sudo \/bin\/systemctl stop firewalld || true\n#sudo \/bin\/systemctl disable firewalld || true\n\nsudo sed -i 's\/SELINUX=enforcing\/SELINUX=disabled\/' \/etc\/selinux\/config\nsudo setenforce 0\n\n\n\n","script_type":"sh","type":"","command_line_args":"","login_credential_local_reference":{"kind":"app_credential","name":"linux"}},"timeout_secs":"0","type":"EXEC","variable_list":[]},{"target_any_local_reference":{"kind":"app_service","name":"Linux"},"retries":"0","description":"","child_tasks_local_reference_list":[],"name":"InitializeDataDisk","attrs":{"exit_status":[],"script":"# region headers\n# * author:     stephane.bourdeaud@nutanix.com\n# * version:    v1.0\/20210504 - cita-starter version\n# task_name:    InitializeDataDisk\n# description:  configured \/dev\/sdb1 as an lvm volume, formats it\n#               as ext4 and mounts it in \/data, also configuring\n#               fstab.               \n# output vars:  none\n# dependencies: none\n# endregion\n\nsudo yum install -y lvm2\nprintf 'o\\nn\\np\\n\\n\\n\\nt\\n8e\\nw' | sudo fdisk \/dev\/sdb\nsudo pvcreate \/dev\/sdb1\nsudo vgcreate vg0 \/dev\/sdb1\nsudo lvcreate -n data -l 100%FREE vg0\nsudo mkfs.ext4 \/dev\/vg0\/data\nsudo mkdir \/data\nsudo mount \/dev\/vg0\/data \/data\necho '\/dev\/mapper\/vg0-data \/data ext4 defaults 0 0' | sudo tee -a \/etc\/fstab","script_type":"sh","type":"","command_line_args":"","login_credential_local_reference":{"kind":"app_credential","name":"linux"}},"timeout_secs":"0","type":"EXEC","variable_list":[]},{"target_any_local_reference":{"kind":"app_service","name":"Linux"},"retries":"0","description":"","child_tasks_local_reference_list":[],"name":"ApplyLinuxUpdates","attrs":{"exit_status":[],"script":"# region headers\n# * author:     stephane.bourdeaud@nutanix.com\n# * version:    v1.0\/20210504 - cita-starter version\n# task_name:    ApplyLinuxUpdates\n# description:  applies updates and upgrades from default yum repo.               \n# output vars:  none\n# dependencies: none\n# endregion\n\n#this is required or update will fail on filesystem package\nsudo umount \/mnt\n\nsudo yum update -y\nsudo yum upgrade -y","script_type":"sh","type":"","command_line_args":"","login_credential_local_reference":{"kind":"app_credential","name":"linux"}},"timeout_secs":"0","type":"EXEC","variable_list":[]},{"target_any_local_reference":{"kind":"app_service","name":"Linux"},"retries":"0","description":"","child_tasks_local_reference_list":[],"name":"PcMountNgt","attrs":{"script":"# region headers\n# escript-template v20190523 \/ stephane.bourdeaud@nutanix.com\n# * author:       stephane.bourdeaud@nutanix.com\n# * version:      2019\/06\/04\n# task_name:      PcMountNgt\n# description:    This script mounts the Nutanix Guest Tools on the AHV\n#                 virtual machine provisioned by Calm.\n# endregion\n\n# region capture Calm macros\npc_user = \"@@{prism_central.username}@@\"\npc_password = \"@@{prism_central.secret}@@\"\nvm_uuid = \"@@{platform.metadata.uuid}@@\"\ncluster_uuid = \"@@{platform.status.cluster_reference.uuid}@@\"\npc_ip = \"@@{prism_central_ip}@@\"\n# endregion\n\n# region prepare variables\ncluster_uuid_url = \"https:\/\/{}:9440\/api\/nutanix\/v3\/clusters\/{}\".format(\n    pc_ip,\n    cluster_uuid\n)\nheaders = {\n    'Accept': 'application\/json',\n    'Content-Type': 'application\/json; charset=UTF-8'\n}\n# endregion\n\n\n# region functions\nimport requests\n\ndef process_request(url, method, user, password, headers, payload=None, secure=False):\n    if payload is not None:\n        payload = json.dumps(payload)\n    \n    #configuring web request behavior\n    timeout=10\n    retries = 5\n    sleep_between_retries = 5\n    \n    while retries > 0:\n        try:\n\n            if method == 'POST':\n                    r = requests.post(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'DELETE':\n                r = requests.delete(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'GET':\n                r = requests.get(\n                    url,\n                    headers=headers,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PUT':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PATCH':\n                    r = requests.patch(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n        except requests.exceptions.HTTPError as e:\n            print (\"Http Error!\")\n            print(\"status code: {}\".format(r.status_code))\n            print(\"reason: {}\".format(r.reason))\n            print(\"text: {}\".format(r.text))\n            print(\"elapsed: {}\".format(r.elapsed))\n            print(\"headers: {}\".format(r.headers))\n            if payload is not None:\n                print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(r.content),\n                indent=4\n            ))\n            exit(r.status_code)\n        except requests.exceptions.ConnectionError as e:\n            print (\"Connection Error!\")\n            if retries == 1:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                exit(1)\n            else:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n            print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n            exit(1)\n        except requests.exceptions.Timeout as e:\n            print (\"Timeout Error!\")\n            if retries == 1:\n                raise Exception(e)\n            else:\n                print('Error! Code: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n        except requests.exceptions.RequestException as e:\n            print (\"Error!\")\n            exit(r.status_code)\n        break\n    \n    if r.ok:\n        return r\n    if r.status_code == 401:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        exit(r.status_code)\n    elif r.status_code == 500:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        exit(r.status_code)\n    else:\n        print(\"Request failed!\")\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        print(\"raise_for_status: {0}\".format(r.raise_for_status()))\n        print(\"elapsed: {0}\".format(r.elapsed))\n        print(\"headers: {0}\".format(r.headers))\n        if payload is not None:\n            print(\"payload: {0}\".format(payload))\n        print(json.dumps(\n            json.loads(r.content),\n            indent=4\n        ))\n        exit(r.status_code)\n        \n# endregion\n\n# region get the AHV cluster IP address\nmethod = 'GET'\nurl = cluster_uuid_url\nprint(\"Retrieving cluster IP address...\")\nprint(\"Making a {} API call to {}\".format(method, url))\nresp = process_request(url, method, pc_user, pc_password, headers)\n\nif resp.ok:\n    result = json.loads(resp.content)\n    # print the content of the response\n    print(json.dumps(\n        json.loads(resp.content),\n        indent=4\n    ))\n    cluster_ip = result[\"status\"][\"resources\"][\"network\"][\"external_ip\"]\n    print(\"The AHV cluster IP address is {}\".format(cluster_ip))\nelse:\n    # print the content of the response (which should have the error message)\n    print(\"Request failed!\")\n    print(\"status code: {}\".format(r.status_code))\n    print(\"reason: {}\".format(r.reason))\n    print(\"text: {}\".format(r.text))\n    print(\"raise_for_status: {}\".format(r.raise_for_status()))\n    print(\"elapsed: {}\".format(r.elapsed))\n    print(\"headers: {}\".format(r.headers))\n    print(\"payload: {}\".format(payload))\n    print(json.dumps(\n        json.loads(resp.content),\n        indent=4\n    ))\n    exit(1)\n# endregion\n\n# region mount the NGT image (to regenerate the certificates)\nmethod = 'POST'\nurl = \"https:\/\/{}:9440\/PrismGateway\/services\/rest\/v1\/vms\/{}\/guest_tools\/mount\".format(\n    cluster_ip,\n    vm_uuid\n)\nprint(\"Mounting NGT...\")\nprint(\"Making a {} API call to {}\".format(method, url))\nresp = process_request(url, method, pc_user, pc_password, headers)\nresult = json.loads(resp.content)\n\nif resp.ok:\n    # print the content of the response\n    print(json.dumps(\n        json.loads(resp.content),\n        indent=4\n    ))\n    print(\"NGT mounted\")\n    exit(0)\nelse:\n    # print the content of the response (which should have the error message)\n    print(\"Request failed!\")\n    print(\"status code: {}\".format(r.status_code))\n    print(\"reason: {}\".format(r.reason))\n    print(\"text: {}\".format(r.text))\n    print(\"raise_for_status: {}\".format(r.raise_for_status()))\n    print(\"elapsed: {}\".format(r.elapsed))\n    print(\"headers: {}\".format(r.headers))\n    print(\"payload: {}\".format(payload))\n    print(json.dumps(\n        json.loads(resp.content),\n        indent=4\n    ))\n    exit(1)\n# endregion","type":"","command_line_args":"","exit_status":[],"script_type":"static"},"timeout_secs":"0","type":"EXEC","variable_list":[]},{"target_any_local_reference":{"kind":"app_service","name":"Linux"},"retries":"0","description":"","child_tasks_local_reference_list":[],"name":"Wait20","attrs":{"type":"","interval_secs":20},"timeout_secs":"0","type":"DELAY","variable_list":[]},{"target_any_local_reference":{"kind":"app_service","name":"Linux"},"retries":"0","description":"","child_tasks_local_reference_list":[],"name":"InstallNgt","attrs":{"exit_status":[],"script":"# region headers\n# * author:     stephane.bourdeaud@nutanix.com\n# * version:    v1.0\/20210504 - cita-starter version\n# task_name:    InstallNgt\n# description:  mounts the ngt iso (assuming \/dev\/sr0) and installs\n#               Nutanix Guest Tools.               \n# output vars:  none\n# dependencies: none\n# endregion\nsleep 15\nsudo mount \/dev\/sr0 \/media\nsudo \/media\/installer\/linux\/install_ngt.py\n","script_type":"sh","type":"","command_line_args":"","login_credential_local_reference":{"kind":"app_credential","name":"linux"}},"timeout_secs":"0","type":"EXEC","variable_list":[]},{"target_any_local_reference":{"kind":"app_service","name":"Linux"},"retries":"0","description":"","child_tasks_local_reference_list":[],"name":"PcEnableNewNgt","attrs":{"script":"# region headers\n# escript-template v20190523 \/ stephane.bourdeaud@nutanix.com\n# * author:       salaheddine.gassim@nutanix.com, stephane.bourdeaud@nutanix.com\n# * version:      2019\/06\/04\n# task_name:      PcEnableNewNgt\n# description:    This script enables the Nutanix Guest Tools on the AHV\n#                 virtual machine provisioned by Calm. It assumes NGT has been\n#                 installed after the VM was deployed (as opposed to being\n#                 pre-installed in the VM template).\n# endregion\n\n# region capture Calm macros\npc_user = \"@@{prism_central.username}@@\"\npc_password = \"@@{prism_central.secret}@@\"\nvm_uuid = \"@@{platform.metadata.uuid}@@\"\ncluster_uuid = \"@@{platform.status.cluster_reference.uuid}@@\"\npc_ip = \"@@{prism_central_ip}@@\"\n# endregion\n\n# region prepare variables\nvm_uuid_url = \"https:\/\/{}:9440\/api\/nutanix\/v3\/vms\/{}\".format(\n    pc_ip,\n    vm_uuid\n)\ncluster_uuid_url = \"https:\/\/{}:9440\/api\/nutanix\/v3\/clusters\/{}\".format(\n    pc_ip,\n    cluster_uuid\n)\nheaders = {\n    'Accept': 'application\/json',\n    'Content-Type': 'application\/json; charset=UTF-8'\n}\n# endregion\n\n\n# region functions\nimport requests\n\ndef process_request(url, method, user, password, headers, payload=None, secure=False):\n    if payload is not None:\n        payload = json.dumps(payload)\n    \n    #configuring web request behavior\n    timeout=10\n    retries = 5\n    sleep_between_retries = 5\n    \n    while retries > 0:\n        try:\n\n            if method == 'POST':\n                    r = requests.post(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'DELETE':\n                r = requests.delete(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'GET':\n                r = requests.get(\n                    url,\n                    headers=headers,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PUT':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PATCH':\n                    r = requests.patch(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n        except requests.exceptions.HTTPError as e:\n            print (\"Http Error!\")\n            print(\"status code: {}\".format(r.status_code))\n            print(\"reason: {}\".format(r.reason))\n            print(\"text: {}\".format(r.text))\n            print(\"elapsed: {}\".format(r.elapsed))\n            print(\"headers: {}\".format(r.headers))\n            if payload is not None:\n                print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(r.content),\n                indent=4\n            ))\n            exit(r.status_code)\n        except requests.exceptions.ConnectionError as e:\n            print (\"Connection Error!\")\n            if retries == 1:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                exit(1)\n            else:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n            print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n            exit(1)\n        except requests.exceptions.Timeout as e:\n            print (\"Timeout Error!\")\n            if retries == 1:\n                raise Exception(e)\n            else:\n                print('Error! Code: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n        except requests.exceptions.RequestException as e:\n            print (\"Error!\")\n            exit(r.status_code)\n        break\n    \n    if r.ok:\n        return r\n    if r.status_code == 401:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        exit(r.status_code)\n    elif r.status_code == 500:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        exit(r.status_code)\n    else:\n        print(\"Request failed!\")\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        print(\"raise_for_status: {0}\".format(r.raise_for_status()))\n        print(\"elapsed: {0}\".format(r.elapsed))\n        print(\"headers: {0}\".format(r.headers))\n        if payload is not None:\n            print(\"payload: {0}\".format(payload))\n        print(json.dumps(\n            json.loads(r.content),\n            indent=4\n        ))\n        exit(r.status_code)\n        \n# endregion\n\n# region get the AHV cluster IP address\nmethod = 'GET'\nurl = cluster_uuid_url\nprint(\"Retrieving cluster IP address...\")\nprint(\"Making a {} API call to {}\".format(method, url))\nresp = process_request(url, method, pc_user, pc_password, headers)\n\nif resp.ok:\n    result = json.loads(resp.content)\n    # print the content of the response\n    print(json.dumps(\n        json.loads(resp.content),\n        indent=4\n    ))\n    cluster_ip = result[\"status\"][\"resources\"][\"network\"][\"external_ip\"]\n    print(\"The AHV cluster IP address is {}\".format(cluster_ip))\nelse:\n    # print the content of the response (which should have the error message)\n    print(\"Request failed!\")\n    print(\"status code: {}\".format(r.status_code))\n    print(\"reason: {}\".format(r.reason))\n    print(\"text: {}\".format(r.text))\n    print(\"raise_for_status: {}\".format(r.raise_for_status()))\n    print(\"elapsed: {}\".format(r.elapsed))\n    print(\"headers: {}\".format(r.headers))\n    print(\"payload: {}\".format(payload))\n    print(json.dumps(\n        json.loads(resp.content),\n        indent=4\n    ))\n    exit(1)\n# endregion\n\n# region enable guest tools for the VM\nmethod = 'POST'\nurl = \"https:\/\/{}:9440\/PrismGateway\/services\/rest\/v1\/vms\/{}::{}\/guest_tools\".format(\n    cluster_ip,\n    cluster_uuid,\n    vm_uuid\n)\nprint(\"Enabling NGT...\")\nprint(\"Making a {} API call to {}\".format(method, url))\npayload = {\n    \"vmUuid\": cluster_uuid + \"::\" + vm_uuid,\n    \"enabled\": \"true\",\n    \"applications\": {\n        \"file_level_restore\": \"false\",\n        \"vss_snapshot\": \"true\"\n    }\n}\nresp = process_request(url, method, pc_user, pc_password, headers, payload)\n\nif resp.ok:\n    result = json.loads(resp.content)\n    # print the content of the response\n    print(json.dumps(\n        json.loads(resp.content),\n        indent=4\n    ))\n    print(\"NGT enabled\")\n    exit(0)\nelse:\n    # print the content of the response (which should have the error message)\n    print(\"Request failed!\")\n    print(\"status code: {}\".format(r.status_code))\n    print(\"reason: {}\".format(r.reason))\n    print(\"text: {}\".format(r.text))\n    print(\"raise_for_status: {}\".format(r.raise_for_status()))\n    print(\"elapsed: {}\".format(r.elapsed))\n    print(\"headers: {}\".format(r.headers))\n    print(\"payload: {}\".format(payload))\n    print(json.dumps(\n        json.loads(resp.content),\n        indent=4\n    ))\n    exit(1)\n# endregion","type":"","command_line_args":"","exit_status":[],"script_type":"static"},"timeout_secs":"0","type":"EXEC","variable_list":[]}],"description":"","name":"AHV_Package___install___runbook","main_task_local_reference":{"kind":"app_task","name":"AHV_Package___install___dag"},"variable_list":[]},"type":"","uninstall_runbook":{"task_definition_list":[{"target_any_local_reference":{"kind":"app_service","name":"Linux"},"retries":"0","description":"","child_tasks_local_reference_list":[],"name":"DAG_Task_for_Package_AHV_Package_action_uninstall","attrs":{"edges":[],"type":""},"timeout_secs":"0","type":"DAG","variable_list":[]}],"description":"","name":"Runbook_for_Package_AHV_Package_action_uninstall","main_task_local_reference":{"kind":"app_task","name":"DAG_Task_for_Package_AHV_Package_action_uninstall"},"variable_list":[]}},"variable_list":[]},{"description":"","action_list":[],"type":"CUSTOM","service_local_reference_list":[{"kind":"app_service","name":"Linux"}],"name":"vSphere_Package","version":"","options":{"install_runbook":{"task_definition_list":[{"target_any_local_reference":{"kind":"app_service","name":"Linux"},"retries":"0","description":"","child_tasks_local_reference_list":[{"kind":"app_task","name":"DisableSelinux"},{"kind":"app_task","name":"InitializeDataDisk"},{"kind":"app_task","name":"ApplyLinuxUpdates"}],"name":"vSphere_Package___install___dag","attrs":{"edges":[{"from_task_reference":{"kind":"app_task","name":"DisableSelinux"},"edge_type":"user_defined","type":"","to_task_reference":{"kind":"app_task","name":"InitializeDataDisk"}},{"from_task_reference":{"kind":"app_task","name":"InitializeDataDisk"},"edge_type":"user_defined","type":"","to_task_reference":{"kind":"app_task","name":"ApplyLinuxUpdates"}}],"type":""},"timeout_secs":"0","type":"DAG","variable_list":[]},{"target_any_local_reference":{"kind":"app_service","name":"Linux"},"retries":"0","description":"","child_tasks_local_reference_list":[],"name":"DisableSelinux","attrs":{"exit_status":[],"script":"#!\/bin\/bash\n\n# region headers\n# * author:     stephane.bourdeaud@nutanix.com\n# * version:    v1.0\/20210504 - cita-starter version\n# task_name:    DisableSelinux\n# description:  disables enforcement of selinux policy.               \n# output vars:  none\n# dependencies: none\n# endregion\n\nsudo hostnamectl set-hostname --static @@{vm_name}@@\necho \"@@{address}@@  @@{vm_name}@@.@@{domain}@@ @@{vm_name}@@\" | sudo tee -a \/etc\/hosts\n\n#sudo \/bin\/systemctl stop firewalld || true\n#sudo \/bin\/systemctl disable firewalld || true\n\nsudo sed -i 's\/SELINUX=enforcing\/SELINUX=disabled\/' \/etc\/selinux\/config\nsudo setenforce 0\n\n\n\n","script_type":"sh","type":"","command_line_args":"","login_credential_local_reference":{"kind":"app_credential","name":"linux"}},"timeout_secs":"0","type":"EXEC","variable_list":[]},{"target_any_local_reference":{"kind":"app_service","name":"Linux"},"retries":"0","description":"","child_tasks_local_reference_list":[],"name":"InitializeDataDisk","attrs":{"exit_status":[],"script":"# region headers\n# * author:     stephane.bourdeaud@nutanix.com\n# * version:    v1.0\/20210504 - cita-starter version\n# task_name:    InitializeDataDisk\n# description:  configured \/dev\/sdb1 as an lvm volume, formats it\n#               as ext4 and mounts it in \/data, also configuring\n#               fstab.               \n# output vars:  none\n# dependencies: none\n# endregion\n\nsudo yum install -y lvm2\nprintf 'o\\nn\\np\\n\\n\\n\\nt\\n8e\\nw' | sudo fdisk \/dev\/sdb\nsudo pvcreate \/dev\/sdb1\nsudo vgcreate vg0 \/dev\/sdb1\nsudo lvcreate -n data -l 100%FREE vg0\nsudo mkfs.ext4 \/dev\/vg0\/data\nsudo mkdir \/data\nsudo mount \/dev\/vg0\/data \/data\necho '\/dev\/mapper\/vg0-data \/data ext4 defaults 0 0' | sudo tee -a \/etc\/fstab","script_type":"sh","type":"","command_line_args":"","login_credential_local_reference":{"kind":"app_credential","name":"linux"}},"timeout_secs":"0","type":"EXEC","variable_list":[]},{"target_any_local_reference":{"kind":"app_service","name":"Linux"},"retries":"0","description":"","child_tasks_local_reference_list":[],"name":"ApplyLinuxUpdates","attrs":{"exit_status":[],"script":"# region headers\n# * author:     stephane.bourdeaud@nutanix.com\n# * version:    v1.0\/20210504 - cita-starter version\n# task_name:    ApplyLinuxUpdates\n# description:  applies updates and upgrades from default yum repo.               \n# output vars:  none\n# dependencies: none\n# endregion\n\n#this is required or update will fail on filesystem package\nsudo umount \/mnt\n\nsudo yum update -y\nsudo yum upgrade -y","script_type":"sh","type":"","command_line_args":"","login_credential_local_reference":{"kind":"app_credential","name":"linux"}},"timeout_secs":"0","type":"EXEC","variable_list":[]}],"description":"","name":"vSphere_Package___install___runbook","main_task_local_reference":{"kind":"app_task","name":"vSphere_Package___install___dag"},"variable_list":[]},"type":"","uninstall_runbook":{"task_definition_list":[{"target_any_local_reference":{"kind":"app_service","name":"Linux"},"retries":"0","description":"","child_tasks_local_reference_list":[],"name":"DAG_Task_for_Package_vSphere_Package_action_uninstall","attrs":{"edges":[],"type":""},"timeout_secs":"0","type":"DAG","variable_list":[]}],"description":"","name":"Runbook_for_Package_vSphere_Package_action_uninstall","main_task_local_reference":{"kind":"app_task","name":"DAG_Task_for_Package_vSphere_Package_action_uninstall"},"variable_list":[]}},"variable_list":[]}],"app_profile_list":[{"deployment_create_list":[{"type":"GREENFIELD","action_list":[],"name":"6ca90e2b_deployment","min_replicas":"1","default_replicas":"1","depends_on_list":[],"published_service_local_reference_list":[],"max_replicas":"1","package_local_reference_list":[{"kind":"app_package","name":"AHV_Package"}],"substrate_local_reference":{"kind":"app_substrate","name":"AHVVM"},"options":{"type":""},"variable_list":[],"description":""}],"environment_reference_list":[],"description":"","action_list":[],"name":"AHV","variable_list":[{"regex":{"should_validate":true,"value":"^\\s*(?:\\S\\s*){3,15}$"},"val_type":"STRING","is_mandatory":true,"description":"Enter the hostname to give to this Linux virtual machine (max 15 characters). This will also be the VM name in the hypervisor.","data_type":"BASE","type":"LOCAL","name":"vm_name","value":"cita-l1","label":"Hostname","attrs":{"type":""},"editables":{"value":true},"is_hidden":false},{"val_type":"STRING","is_mandatory":true,"description":"Fully qualified DNS domain name.","data_type":"BASE","type":"LOCAL","name":"domain","value":"gso.lab","label":"DNS domain name (fqdn)","attrs":{"type":""},"editables":{"value":true},"is_hidden":false},{"regex":{"should_validate":false,"value":" "},"val_type":"STRING","is_mandatory":false,"description":"","data_type":"BASE","type":"LOCAL","name":"email_sender","value":"stephane.bourdeaud@nutanix.com","label":"","attrs":{"type":""},"is_hidden":true},{"val_type":"STRING","is_mandatory":true,"description":"This is used in the email notification and will also be part of the application instance definition for future references.","data_type":"BASE","type":"LOCAL","name":"vm_requester_name","value":"Stephane Bourdeaud","label":"Your full name","attrs":{"type":""},"editables":{"value":true},"is_hidden":false},{"val_type":"STRING","is_mandatory":true,"description":"This will be used to send you a notification with the provisioned VM details, including credentials.","data_type":"BASE","type":"LOCAL","name":"requester_email","value":"stephane.bourdeaud@nutanix.com","label":"Your email address","attrs":{"type":""},"editables":{"value":true},"is_hidden":false},{"val_type":"STRING","is_mandatory":false,"description":"","data_type":"BASE","type":"LOCAL","name":"smtp_server","value":"10.40.64.35","label":"","attrs":{"type":""},"is_hidden":true},{"regex":{"should_validate":true,"value":"^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$"},"val_type":"STRING","is_mandatory":false,"description":"","data_type":"BASE","type":"LOCAL","name":"prism_central_ip","value":"127.0.0.1","label":"","attrs":{"type":""},"is_hidden":true},{"val_type":"STRING","is_mandatory":false,"description":"","data_type":"BASE","type":"LOCAL","name":"org","value":"Nutanix","label":"","attrs":{"type":""},"is_hidden":false},{"val_type":"STRING","is_mandatory":true,"description":"Paste here your SSL public key","data_type":"BASE","type":"LOCAL","name":"public_key","value":"xxx","label":"","attrs":{"type":""},"editables":{"value":true},"is_hidden":false},{"val_type":"STRING","is_mandatory":false,"description":"IP address or FQDN for your phpIPAM server.","data_type":"BASE","type":"LOCAL","name":"phpipam_ip","value":"phpipam.xpert-services.eu","label":"","attrs":{"type":""},"is_hidden":true},{"val_type":"STRING","is_mandatory":false,"description":"Name of the API application created in phpIPAM.","data_type":"BASE","type":"LOCAL","name":"phpipam_app_id","value":"calm","label":"","attrs":{"type":""},"is_hidden":true},{"val_type":"STRING","is_mandatory":false,"description":"This is the section id in phpipam where the vlan\/subnet exists (1 matches \"Customers\" by default; you can check the section id by navigating to your subnet in phpIPAM and looking at the url)","data_type":"BASE","type":"LOCAL","name":"phpipam_section_id","value":"1","label":"","attrs":{"type":""},"is_hidden":true},{"val_type":"STRING","is_mandatory":false,"description":"Id of the VLAN from which to get an IP in phpIPAM.","data_type":"BASE","type":"LOCAL","name":"vlan_id","value":"568","label":"","attrs":{"type":""},"is_hidden":true}]},{"deployment_create_list":[{"type":"GREENFIELD","action_list":[],"name":"04e86344_deployment","min_replicas":"1","default_replicas":"1","depends_on_list":[],"published_service_local_reference_list":[],"max_replicas":"1","package_local_reference_list":[{"kind":"app_package","name":"vSphere_Package"}],"substrate_local_reference":{"kind":"app_substrate","name":"vSphereVM"},"options":{"type":""},"variable_list":[],"description":""}],"environment_reference_list":[],"description":"","action_list":[],"name":"vSphere","variable_list":[{"regex":{"should_validate":true,"value":"^\\s*(?:\\S\\s*){3,15}$"},"val_type":"STRING","is_mandatory":true,"description":"Enter the hostname to give to this Linux virtual machine (max 15 characters). This will also be the VM name in the hypervisor.","data_type":"BASE","type":"LOCAL","name":"vm_name","value":"cita-l1","label":"Hostname","attrs":{"type":""},"editables":{"value":true},"is_hidden":false},{"val_type":"STRING","is_mandatory":true,"description":"Fully qualified DNS domain name.","data_type":"BASE","type":"LOCAL","name":"domain","value":"gso.lab","label":"DNS domain name (fqdn)","attrs":{"type":""},"editables":{"value":true},"is_hidden":false},{"regex":{"should_validate":false,"value":" "},"val_type":"STRING","is_mandatory":false,"description":"","data_type":"BASE","type":"LOCAL","name":"email_sender","value":"stephane.bourdeaud@nutanix.com","label":"","attrs":{"type":""},"is_hidden":true},{"val_type":"STRING","is_mandatory":true,"description":"This is used in the email notification and will also be part of the application instance definition for future references.","data_type":"BASE","type":"LOCAL","name":"vm_requester_name","value":"Stephane Bourdeaud","label":"Your full name","attrs":{"type":""},"editables":{"value":true},"is_hidden":false},{"regex":{"should_validate":false,"value":" "},"val_type":"STRING","is_mandatory":true,"description":"This will be used to send you a notification with the provisioned VM details, including credentials.","data_type":"BASE","type":"LOCAL","name":"requester_email","value":"stephane.bourdeaud@nutanix.com","label":"Your email address","attrs":{"type":""},"editables":{"value":true},"is_hidden":false},{"val_type":"STRING","is_mandatory":false,"description":"","data_type":"BASE","type":"LOCAL","name":"smtp_server","value":"10.40.64.35","label":"","attrs":{"type":""},"is_hidden":true},{"val_type":"STRING","is_mandatory":false,"description":"","data_type":"BASE","type":"LOCAL","name":"org","value":"Nutanix","label":"","attrs":{"type":""},"is_hidden":false},{"val_type":"STRING","is_mandatory":true,"description":"Paste here your SSL public key","data_type":"BASE","type":"LOCAL","name":"public_key","value":"xxx","label":"","attrs":{"type":""},"editables":{"value":true},"is_hidden":false},{"val_type":"STRING","is_mandatory":false,"description":"IP address or FQDN for your phpIPAM server.","data_type":"BASE","type":"LOCAL","name":"phpipam_ip","value":"phpipam.xpert-services.eu","label":"","attrs":{"type":""},"is_hidden":true},{"val_type":"STRING","is_mandatory":false,"description":"Name of the API application created in phpIPAM.","data_type":"BASE","type":"LOCAL","name":"phpipam_app_id","value":"calm","label":"","attrs":{"type":""},"is_hidden":true},{"val_type":"STRING","is_mandatory":false,"description":"This is the section id in phpipam where the vlan\/subnet exists (1 matches \"Customers\" by default; you can check the section id by navigating to your subnet in phpIPAM and looking at the url)","data_type":"BASE","type":"LOCAL","name":"phpipam_section_id","value":"1","label":"","attrs":{"type":""},"is_hidden":true},{"val_type":"STRING","is_mandatory":false,"description":"Id of the VLAN from which to get an IP in phpIPAM.","data_type":"BASE","type":"LOCAL","name":"vlan_id","value":"568","label":"","attrs":{"type":""},"is_hidden":true}]}],"published_service_definition_list":[],"default_credential_local_reference":{"kind":"app_credential","name":"linux"},"type":"USER"},"name":"cita-starter-linux-f3-phpipam-v2"},"api_version":"3.0","metadata":{"last_update_time":"1622039928809770","kind":"blueprint","spec_version":1,"creation_time":"1622039921714142","name":"cita-starter-linux-f3-phpipam-v2"}}